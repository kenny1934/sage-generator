<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAGE: Secondary Academy Generator of Exercises ‚ú®</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- KaTeX CSS for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" xintegrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
    <!-- KaTeX JS for math rendering -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" xintegrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" xintegrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    
    <!-- Google APIs for Drive integration (optional) -->
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>

    <!-- SAGE CSS Files -->
    <link rel="stylesheet" href="css/themes.css">
    <link rel="stylesheet" href="css/animations.css">
    <link rel="stylesheet" href="css/layout.css">
    <link rel="stylesheet" href="css/main.css">

    <!-- All CSS is now in external files -->
</head>
<body>
    <div class="app-layout">
        <!-- App Header -->
        <header class="app-header">
            <!-- Left: Logo & Branding -->
            <div class="header-left">
                <img src="./images/msa-logo.png" alt="MSA Logo" class="logo" onerror="this.onerror=null;this.src='https://placehold.co/100x100/ffffff/dc2626?text=Logo';">
                <div class="header-text">
                    <h1 class="sage-title">SAGE</h1>
                    <div class="divider"></div>
                    <div class="full-name">
                        <span class="em">S</span>econdary <span class="em">A</span>cademy <span class="em">G</span>enerator of <span class="em">E</span>xercises
                    </div>
                </div>
            </div>
            
            <!-- Right: Theme Toggle -->
            <div class="header-right">
                <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
                    <span class="theme-icon">üåô</span>
                </button>
            </div>
        </header>


        <!-- Main Content Area -->
        <div class="app-main">
            <!-- Left Config Panel -->
            <aside class="config-panel main-container">
                <div class="config-content">
                    <!-- Configuration sections will go here -->

            
            <!-- Google Drive Setup (hidden by default) -->
            <div id="googleDriveSetupPanel" class="mb-6 p-4 bg-blue-900/20 border border-blue-600/30 rounded-lg hidden">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold text-blue-200">
                        ‚òÅÔ∏è Google Drive Setup
                    </h3>
                    <button type="button" class="text-blue-400 hover:text-blue-300 text-sm" onclick="hideGoogleDriveSetup()">Close</button>
                </div>
                <div class="text-sm text-blue-200 mb-4">
                    <p class="mb-2">Enable multi-device sync for your Google Workspace:</p>
                    <ol class="list-decimal list-inside space-y-1 text-blue-300 text-xs">
                        <li>Go to <a href="https://console.cloud.google.com" target="_blank" class="text-blue-400 underline">Google Cloud Console</a></li>
                        <li>Enable the Google Drive API</li>
                        <li>Create OAuth 2.0 Client ID (Web application)</li>
                        <li>Add <code class="bg-gray-700 px-1 rounded text-blue-200" id="currentOriginDisplay">your current URL</code> to "Authorized JavaScript origins"</li>
                        <li>Enter Client ID below</li>
                    </ol>
                </div>
                <div class="grid grid-cols-1 gap-3">
                    <div>
                        <label for="googleClientId" class="block text-sm font-medium text-blue-200 mb-1">Google OAuth Client ID:</label>
                        <input type="text" id="googleClientId" class="w-full p-2 text-sm bg-gray-800 border border-blue-500 rounded" placeholder="123456789-abcdefg.apps.googleusercontent.com">
                    </div>
                    <button type="button" class="action-btn bg-blue-600 hover:bg-blue-700 text-sm" onclick="saveGoogleDriveConfig()">
                        Save Configuration
                    </button>
                </div>
            </div>

            <!-- API Key Configuration -->
            <div id="apiKeyContainer" class="api-key-container">
                <label for="apiKeyInput" class="block text-sm font-semibold text-gray-200 mb-2">
                    Gemini API Key (required):
                </label>
                <div class="flex gap-2">
                    <input type="password" id="apiKeyInput" class="flex-1" placeholder="Enter your Gemini API key" aria-label="Gemini API Key">
                    <button id="saveApiKeyBtn" class="action-btn bg-red-600 hover:bg-red-700" aria-label="Save API Key">
                        Save
                    </button>
                </div>
                <p class="text-xs text-gray-400 mt-1">
                    Your API key is stored locally and never sent to our servers.
                </p>
            </div>
            
            <!-- Phase 4: Data Management Section -->
            <div id="dataManagementContainer" class="mb-6 p-4 rounded-lg" style="background: var(--surface); border: 1px solid var(--border-color);">
                <h3 class="text-lg font-semibold mb-3" style="color: var(--text-primary);">Data Management</h3>
                <div class="flex gap-2 flex-wrap mb-3">
                    <button id="exportDataBtn" class="action-btn text-sm px-3 py-2 rounded transition-colors" 
                            style="background: #059669; border: 1px solid #047857; color: white;"
                            onmouseover="this.style.background='#047857'" 
                            onmouseout="this.style.background='#059669'">
                        üì¶ Export All Data
                    </button>
                    <button id="importDataBtn" class="action-btn text-sm px-3 py-2 rounded transition-colors"
                            style="background: #2563eb; border: 1px solid #1d4ed8; color: white;"
                            onmouseover="this.style.background='#1d4ed8'" 
                            onmouseout="this.style.background='#2563eb'">
                        üì• Import Data
                    </button>
                    <button id="clearDataBtn" class="action-btn text-sm px-3 py-2 rounded transition-colors"
                            style="background: #dc2626; border: 1px solid #b91c1c; color: white;"
                            onmouseover="this.style.background='#b91c1c'" 
                            onmouseout="this.style.background='#dc2626'">
                        üóëÔ∏è Clear All
                    </button>
                </div>
                <input type="file" id="importFileInput" class="hidden" accept=".json">
                <p class="text-xs" style="color: var(--text-muted);">
                    Export your preferences, history, favorites, streaks, and stats for backup or transfer between devices.
                </p>
            </div>

            <div class="space-y-8">

                <div>
                    <label for="mathTopic" class="block text-lg font-semibold mb-2">
                        Maths Topic & Grade Level <span class="text-gray-400 text-sm">(e.g., "Algebra for Grade 7", "Trigonometry for Form 3")</span>:
                    </label>
                    <div class="autocomplete-container">
                        <textarea id="mathTopic" rows="3" class="w-full p-3 shadow-sm" placeholder="e.g., 'Solving linear equations in one unknown for F1', 'Complex number problems for Form 4'" aria-label="Maths Topic and Grade Level"></textarea>
                        <div id="autocompleteDropdown" class="autocomplete-dropdown"></div>
                    </div>
                </div>

                <div>
                    <label for="difficulty" class="block text-lg font-semibold mb-2">
                        Difficulty Level:
                    </label>
                    <select id="difficulty" class="w-full p-3 shadow-sm" aria-label="Difficulty Level">
                        <option value="Easy">Easy</option>
                        <option value="Medium" selected>Medium</option>
                        <option value="Hard">Hard</option>
                        <option value="Challenging">Challenging</option>
                    </select>
                    <div id="difficultyDescription" class="difficulty-description">
                        Medium complexity with step-by-step explanations
                    </div>
                </div>

                <button id="generateQuestionsBtn" class="w-full bg-red-600 text-white font-extrabold py-4 px-6 rounded-xl hover:bg-red-700 transition-all duration-300 ease-in-out shadow-lg transform hover:-translate-y-1 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-400 flex items-center justify-center text-xl" aria-label="Generate Math Questions">
                    Generate Maths Questions! ‚ûï
                </button>

                <div id="loadingIndicator" class="hidden text-center mt-6" role="status" aria-live="polite">
                    <div class="math-spinner justify-center">
                        <span class="math-symbol">œÄ</span>
                        <span class="math-symbol">‚àë</span>
                        <span class="math-symbol">‚à´</span>
                        <span class="math-symbol">‚àû</span>
                    </div>
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill"></div>
                    </div>
                    <div id="loadingMessage" class="loading-message">Initializing math generator...</div>
                </div>

                <div id="questionsContainer" class="hidden mt-10 border-t-2 border-gray-700 pt-10">
                    <div class="flex flex-col sm:flex-row justify-between items-center mb-8 gap-4">
                        <h2 class="text-3xl font-bold text-center sm:text-left flex-grow" style="color: var(--text-primary);">Your Generated Questions</h2>
                        <div class="flex gap-2 flex-wrap">
                            <button id="exportQuestionsBtn" class="action-btn bg-red-500 hover:bg-red-600 text-sm sm:text-base" aria-label="Export questions to text file">
                                Export Questions
                            </button>
                            <button id="showFavoritesBtn" class="action-btn bg-yellow-600 hover:bg-yellow-700 text-sm sm:text-base" aria-label="View your favorite questions" onclick="showFavoritesPanel()">
                                ‚≠ê Favorites
                            </button>
                            <button id="toggleMathViewBtn" class="action-btn bg-gray-500 hover:bg-gray-600 text-sm sm:text-base" aria-label="Toggle between rendered math and raw LaTeX view">
                                Toggle Maths View (Rendered)
                            </button>
                        </div>
                    </div>
                    
                    <!-- Question Navigator -->
                    <div id="questionNavigator" class="question-navigator hidden">
                        <button id="prevQuestionBtn" class="nav-button" aria-label="Previous question">
                            ‚Üê Previous
                        </button>
                        <div class="question-counter" id="questionCounter">
                            Question 1 of 3
                        </div>
                        <button id="nextQuestionBtn" class="nav-button" aria-label="Next question">
                            Next ‚Üí
                        </button>
                    </div>
                    
                    <div id="mathQuestionsList" class="space-y-8" role="list">
                        <!-- Math questions will be inserted here -->
                    </div>
                    <button id="resetBtn" class="hidden w-full bg-gray-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-gray-700 transition-all duration-300 ease-in-out shadow-lg transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-400 mt-8" aria-label="Generate New Questions">
                        Generate New Questions
                    </button>
                </div>

                <div id="messageContainer" class="mt-8" role="alert" aria-live="polite">
                    <p class="text-gray-400 text-center" id="initialMessage">Your generated maths questions will appear here.</p>
                </div>
            </div>
                </div>
            </aside>

            <!-- Right Questions Canvas -->
            <main class="questions-canvas main-container" id="questions-canvas">
                <div class="questions-content">
                    <!-- Questions will be displayed here -->
                    <p class="text-gray-400 text-center" id="questionsPlaceholder">Select a topic and generate questions to see them here.</p>
                </div>
            </main>
        </div>

        <!-- Footer -->
        <footer class="footer">
            <p>&copy; 2025 MathConcept Secondary Academy. All Rights Reserved.</p>
        </footer>
    </div>

    <script>
        // Phase 4: Responsive Layout Management
        class ResponsiveLayoutManager {
            constructor() {
                this.isDesktop = false;
                this.sidebarContent = document.getElementById('sidebar-content');
                this.mainContainer = document.querySelector('.main-container main');
                this.breakpoint = 1024; // Desktop breakpoint
                
                this.init();
            }
            
            init() {
                this.checkLayout();
                window.addEventListener('resize', () => this.checkLayout());
                console.log('Responsive Layout Manager initialized');
            }
            
            checkLayout() {
                const wasDesktop = this.isDesktop;
                this.isDesktop = window.innerWidth >= this.breakpoint;
                
                if (wasDesktop !== this.isDesktop) {
                    this.reorganizeLayout();
                }
            }
            
            reorganizeLayout() {
                console.log(`Layout change: ${this.isDesktop ? 'Desktop' : 'Mobile'} mode`);
                
                if (this.isDesktop) {
                    this.moveToSidebar();
                } else {
                    this.moveToMain();
                }
            }
            
            moveToSidebar() {
                // For now, disable automatic section moving to prevent bugs
                // We'll implement this properly in the new layout design
                console.log('Sidebar layout - sections remain in main content for now');
            }
            
            // Phase 4: Move questions to questions canvas
            moveQuestionsToCanvas() {
                const questionsContainer = document.getElementById('questionsContainer');
                const questionsCanvas = document.querySelector('.questions-content');
                const placeholder = document.getElementById('questionsPlaceholder');
                
                if (questionsContainer && questionsCanvas && this.isDesktop) {
                    // Hide placeholder
                    if (placeholder) placeholder.style.display = 'none';
                    
                    // Move questions container to canvas
                    questionsCanvas.appendChild(questionsContainer);
                    console.log('Questions moved to canvas');
                }
            }
            
            moveToMain() {
                // Move sections back to main content area
                const sidebarSections = this.sidebarContent.querySelectorAll('.sidebar-section');
                sidebarSections.forEach(section => section.remove());
                
                // Show original sections in main content
                const originalSections = [
                    '#statsOverview',
                    '#recentTopicsSection', 
                    '#recommendationsSection'
                ];
                
                originalSections.forEach(selector => {
                    const element = document.querySelector(selector);
                    if (element) {
                        element.style.display = '';
                    }
                });
            }
        }


        // Configuration constants
        const CONFIG = {
            API_BASE_URL: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent',
            MAX_RETRIES: 3,
            RETRY_DELAY: 1000,
            STORAGE_KEY: 'sage_api_key',
            MESSAGE_TIMEOUT: 3000,
            // New storage keys for Phase 3 features
            PREFERENCES_KEY: 'sage_preferences',
            HISTORY_KEY: 'sage_history',
            FAVORITES_KEY: 'sage_favorites',
            STATS_KEY: 'sage_stats',
            STREAKS_KEY: 'sage-streaks',
            THEME_KEY: 'sage-theme',
            // Phase 4: Question caching configuration
            CACHE_KEY: 'sage_question_cache',
            CACHE_EXPIRY_HOURS: 24,
            MAX_CACHE_SIZE: 100
        };

        // Get references to DOM elements
        const mathTopicInput = document.getElementById('mathTopic');
        const difficultySelect = document.getElementById('difficulty');
        const generateQuestionsBtn = document.getElementById('generateQuestionsBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const questionsContainer = document.getElementById('questionsContainer');
        const mathQuestionsList = document.getElementById('mathQuestionsList');
        const resetBtn = document.getElementById('resetBtn');
        const messageContainer = document.getElementById('messageContainer');
        const initialMessage = document.getElementById('initialMessage');
        const toggleMathViewBtn = document.getElementById('toggleMathViewBtn');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
        const apiKeyContainer = document.getElementById('apiKeyContainer');
        const exportQuestionsBtn = document.getElementById('exportQuestionsBtn');

        let isMathRendered = true; // Default state: math is rendered
        let isKaTeXLoaded = false;
        let currentQuestions = []; // Store current questions for export
        let mathRenderCache = new Map(); // Cache for rendered math content
        let isOnline = navigator.onLine;
        let networkStatusIndicator;
        let currentQuestionIndex = 0;
        let totalQuestions = 0;
        
        // Google Drive integration (optional enhancement)
        let googleDriveAvailable = false;
        let isGoogleSignedIn = false;

        // Phase 3: Data Management and Personalization
        class DataManager {
            static loadPreferences() {
                try {
                    const preferences = localStorage.getItem(CONFIG.PREFERENCES_KEY);
                    return preferences ? JSON.parse(preferences) : {
                        preferredDifficulty: 'Medium',
                        preferredTopics: [],
                        lastUsedTopic: '',
                        autoSaveHistory: true,
                        maxHistoryItems: 50
                    };
                } catch (error) {
                    console.error('Error loading preferences:', error);
                    return this.getDefaultPreferences();
                }
            }

            static savePreferences(preferences) {
                try {
                    localStorage.setItem(CONFIG.PREFERENCES_KEY, JSON.stringify(preferences));
                } catch (error) {
                    console.error('Error saving preferences:', error);
                }
            }

            static getDefaultPreferences() {
                return {
                    preferredDifficulty: 'Medium',
                    preferredTopics: [],
                    lastUsedTopic: '',
                    autoSaveHistory: true,
                    maxHistoryItems: 50
                };
            }

            static loadHistory() {
                try {
                    const history = localStorage.getItem(CONFIG.HISTORY_KEY);
                    return history ? JSON.parse(history) : [];
                } catch (error) {
                    console.error('Error loading history:', error);
                    return [];
                }
            }

            static saveHistory(historyItems) {
                try {
                    const preferences = this.loadPreferences();
                    if (!preferences.autoSaveHistory) return;

                    // Limit history size
                    const limitedHistory = historyItems.slice(0, preferences.maxHistoryItems);
                    localStorage.setItem(CONFIG.HISTORY_KEY, JSON.stringify(limitedHistory));
                } catch (error) {
                    console.error('Error saving history:', error);
                }
            }

            static addToHistory(topic, difficulty, questionsCount = 3) {
                const history = this.loadHistory();
                const historyItem = {
                    id: Date.now(),
                    topic: topic.trim(),
                    difficulty,
                    questionsCount,
                    timestamp: new Date().toISOString(),
                    date: new Date().toLocaleDateString()
                };

                // Remove duplicate topics (keep most recent)
                const filteredHistory = history.filter(item => 
                    item.topic.toLowerCase() !== topic.toLowerCase().trim()
                );

                // Add new item at the beginning
                const updatedHistory = [historyItem, ...filteredHistory];
                this.saveHistory(updatedHistory);
                this.updateStats(topic, difficulty);

                return updatedHistory;
            }

            static getRecentTopics(limit = 6) {
                const history = this.loadHistory();
                return history.slice(0, limit).map(item => ({
                    topic: item.topic,
                    difficulty: item.difficulty,
                    lastUsed: item.date
                }));
            }

            static loadStats() {
                try {
                    const stats = localStorage.getItem(CONFIG.STATS_KEY);
                    return stats ? JSON.parse(stats) : {
                        totalQuestions: 0,
                        totalSessions: 0,
                        favoriteTopics: {},
                        difficultyDistribution: {},
                        firstUsed: new Date().toISOString(),
                        lastUsed: new Date().toISOString()
                    };
                } catch (error) {
                    console.error('Error loading stats:', error);
                    return this.getDefaultStats();
                }
            }

            static saveStats(stats) {
                try {
                    localStorage.setItem(CONFIG.STATS_KEY, JSON.stringify(stats));
                } catch (error) {
                    console.error('Error saving stats:', error);
                }
            }

            static updateStats(topic, difficulty) {
                const stats = this.loadStats();
                
                stats.totalQuestions += 3; // Assuming 3 questions per generation
                stats.totalSessions += 1;
                stats.lastUsed = new Date().toISOString();

                // Track favorite topics
                const topicKey = topic.toLowerCase().trim();
                stats.favoriteTopics[topicKey] = (stats.favoriteTopics[topicKey] || 0) + 1;

                // Track difficulty distribution
                stats.difficultyDistribution[difficulty] = (stats.difficultyDistribution[difficulty] || 0) + 1;

                this.saveStats(stats);
            }

            static getDefaultStats() {
                return {
                    totalQuestions: 0,
                    totalSessions: 0,
                    favoriteTopics: {},
                    difficultyDistribution: {},
                    firstUsed: new Date().toISOString(),
                    lastUsed: new Date().toISOString()
                };
            }

            static loadFavorites() {
                try {
                    const favorites = localStorage.getItem(CONFIG.FAVORITES_KEY);
                    return favorites ? JSON.parse(favorites) : [];
                } catch (error) {
                    console.error('Error loading favorites:', error);
                    return [];
                }
            }

            static saveFavorites(favorites) {
                try {
                    localStorage.setItem(CONFIG.FAVORITES_KEY, JSON.stringify(favorites));
                } catch (error) {
                    console.error('Error saving favorites:', error);
                }
            }

            static addToFavorites(question, answer, solution, topic, difficulty) {
                const favorites = this.loadFavorites();
                const favorite = {
                    id: Date.now(),
                    question,
                    answer,
                    solution,
                    topic,
                    difficulty,
                    timestamp: new Date().toISOString(),
                    date: new Date().toLocaleDateString()
                };

                favorites.unshift(favorite);
                this.saveFavorites(favorites);
                return favorites;
            }

            static removeFromFavorites(favoriteId) {
                const favorites = this.loadFavorites();
                const updatedFavorites = favorites.filter(fav => fav.id !== favoriteId);
                this.saveFavorites(updatedFavorites);
                return updatedFavorites;
            }

            // Phase 4: Usage Streaks and Milestones
            static loadStreaksAndMilestones() {
                try {
                    const data = localStorage.getItem(CONFIG.STREAKS_KEY || 'sage-streaks');
                    return data ? JSON.parse(data) : {
                        currentStreak: 0,
                        longestStreak: 0,
                        lastUsageDate: null,
                        totalDaysUsed: 0,
                        milestones: {},
                        achievements: []
                    };
                } catch (error) {
                    console.error('Error loading streaks data:', error);
                    return this.getDefaultStreaksData();
                }
            }

            static saveStreaksAndMilestones(data) {
                try {
                    localStorage.setItem(CONFIG.STREAKS_KEY || 'sage-streaks', JSON.stringify(data));
                } catch (error) {
                    console.error('Error saving streaks data:', error);
                }
            }

            static getDefaultStreaksData() {
                return {
                    currentStreak: 0,
                    longestStreak: 0,
                    lastUsageDate: null,
                    totalDaysUsed: 0,
                    milestones: {},
                    achievements: []
                };
            }

            static updateUsageStreak() {
                const today = new Date().toDateString();
                const streakData = this.loadStreaksAndMilestones();
                
                // If used today, no need to update
                if (streakData.lastUsageDate === today) {
                    return streakData;
                }
                
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayString = yesterday.toDateString();
                
                if (streakData.lastUsageDate === yesterdayString) {
                    // Continue streak
                    streakData.currentStreak += 1;
                } else if (streakData.lastUsageDate === null || streakData.lastUsageDate !== today) {
                    // Start new streak or reset
                    streakData.currentStreak = 1;
                }
                
                // Update data
                streakData.lastUsageDate = today;
                streakData.totalDaysUsed += 1;
                streakData.longestStreak = Math.max(streakData.longestStreak, streakData.currentStreak);
                
                // Check for milestones
                this.checkMilestones(streakData);
                
                this.saveStreaksAndMilestones(streakData);
                return streakData;
            }

            static checkMilestones(streakData) {
                const milestones = [
                    { type: 'streak', value: 3, name: 'Getting Started', description: '3 days in a row!' },
                    { type: 'streak', value: 7, name: 'Week Warrior', description: '7 days streak!' },
                    { type: 'streak', value: 14, name: 'Fortnight Fighter', description: '2 weeks streak!' },
                    { type: 'streak', value: 30, name: 'Monthly Master', description: '30 days streak!' },
                    { type: 'questions', value: 50, name: 'Half Century', description: '50 questions generated!' },
                    { type: 'questions', value: 100, name: 'Centurion', description: '100 questions generated!' },
                    { type: 'questions', value: 500, name: 'Math Machine', description: '500 questions generated!' },
                    { type: 'topics', value: 10, name: 'Topic Explorer', description: '10 different topics!' },
                    { type: 'topics', value: 25, name: 'Subject Master', description: '25 different topics!' }
                ];
                
                const stats = this.loadStats();
                
                milestones.forEach(milestone => {
                    const key = `${milestone.type}_${milestone.value}`;
                    if (!streakData.milestones[key]) {
                        let achieved = false;
                        
                        switch (milestone.type) {
                            case 'streak':
                                achieved = streakData.currentStreak >= milestone.value;
                                break;
                            case 'questions':
                                achieved = stats.totalQuestions >= milestone.value;
                                break;
                            case 'topics':
                                achieved = Object.keys(stats.favoriteTopics).length >= milestone.value;
                                break;
                        }
                        
                        if (achieved) {
                            streakData.milestones[key] = {
                                ...milestone,
                                achievedDate: new Date().toISOString(),
                                isNew: true
                            };
                            streakData.achievements.push(key);
                        }
                    }
                });
            }

            static getNewAchievements() {
                const streakData = this.loadStreaksAndMilestones();
                const newAchievements = Object.values(streakData.milestones)
                    .filter(milestone => milestone.isNew);
                
                // Mark as seen
                Object.keys(streakData.milestones).forEach(key => {
                    if (streakData.milestones[key].isNew) {
                        streakData.milestones[key].isNew = false;
                    }
                });
                this.saveStreaksAndMilestones(streakData);
                
                return newAchievements;
            }

            // Phase 4: Topic Categorization System
            static categorizeTopicByKeywords(topic) {
                if (!topic || typeof topic !== 'string') return 'General';
                
                const topicLower = topic.toLowerCase();
                
                const categories = {
                    'Algebra': [
                        'algebra', 'equation', 'linear', 'quadratic', 'polynomial', 'variable', 'expression', 
                        'solve', 'factor', 'expand', 'simplify', 'inequalities', 'systems', 'matrix', 'matrices'
                    ],
                    'Geometry': [
                        'geometry', 'triangle', 'circle', 'rectangle', 'square', 'polygon', 'angle', 'perimeter', 
                        'area', 'volume', 'circumference', 'radius', 'diameter', 'coordinate', 'point', 'line',
                        'parallel', 'perpendicular', 'congruent', 'similar', 'theorem', 'proof'
                    ],
                    'Calculus': [
                        'calculus', 'derivative', 'integral', 'limit', 'differential', 'integration', 'differentiation',
                        'slope', 'tangent', 'rate', 'optimization', 'maximum', 'minimum', 'curve', 'function'
                    ],
                    'Trigonometry': [
                        'trigonometry', 'sin', 'cos', 'tan', 'sine', 'cosine', 'tangent', 'angle', 'radian', 
                        'degree', 'amplitude', 'period', 'frequency', 'wave', 'oscillation'
                    ],
                    'Statistics': [
                        'statistics', 'probability', 'data', 'mean', 'median', 'mode', 'standard deviation',
                        'variance', 'distribution', 'sample', 'population', 'regression', 'correlation',
                        'hypothesis', 'confidence', 'interval'
                    ],
                    'Number Theory': [
                        'number', 'prime', 'composite', 'factor', 'multiple', 'divisible', 'modular', 'gcd', 
                        'lcm', 'fibonacci', 'sequence', 'series', 'arithmetic', 'geometric'
                    ],
                    'Complex Numbers': [
                        'complex', 'imaginary', 'real', 'conjugate', 'modulus', 'argument', 'polar', 'exponential'
                    ]
                };
                
                for (const [category, keywords] of Object.entries(categories)) {
                    if (keywords.some(keyword => topicLower.includes(keyword))) {
                        return category;
                    }
                }
                
                return 'General';
            }

            static getCategoryColor(category) {
                const colors = {
                    'Algebra': '#3b82f6',      // Blue
                    'Geometry': '#10b981',     // Green  
                    'Calculus': '#f59e0b',     // Orange
                    'Trigonometry': '#8b5cf6', // Purple
                    'Statistics': '#ef4444',   // Red
                    'Number Theory': '#06b6d4', // Cyan
                    'Complex Numbers': '#ec4899', // Pink
                    'General': '#6b7280'       // Gray
                };
                return colors[category] || colors['General'];
            }

            static getCategoryIcon(category) {
                const icons = {
                    'Algebra': 'üî¢',
                    'Geometry': 'üìê',
                    'Calculus': 'üìà',
                    'Trigonometry': 'üìä',
                    'Statistics': 'üìã',
                    'Number Theory': 'üî±',
                    'Complex Numbers': 'üîÆ',
                    'General': 'üìö'
                };
                return icons[category] || icons['General'];
            }
        }

        // Phase 4: Question Cache System
        class QuestionCache {
            static generateCacheKey(topic, difficulty) {
                if (!topic || !difficulty) return null;
                return `${topic.toLowerCase().trim()}_${difficulty.toLowerCase()}`.replace(/\s+/g, '_');
            }

            static loadCache() {
                try {
                    const cacheData = localStorage.getItem(CONFIG.CACHE_KEY);
                    return cacheData ? JSON.parse(cacheData) : {};
                } catch (error) {
                    console.error('Error loading question cache:', error);
                    return {};
                }
            }

            static saveCache(cache) {
                try {
                    localStorage.setItem(CONFIG.CACHE_KEY, JSON.stringify(cache));
                } catch (error) {
                    console.error('Error saving question cache:', error);
                }
            }

            static isExpired(timestamp) {
                const expiryTime = CONFIG.CACHE_EXPIRY_HOURS * 60 * 60 * 1000;
                return Date.now() - timestamp > expiryTime;
            }

            static get(topic, difficulty) {
                const cacheKey = this.generateCacheKey(topic, difficulty);
                if (!cacheKey) return null;

                const cache = this.loadCache();
                const entry = cache[cacheKey];

                if (!entry) return null;

                if (this.isExpired(entry.timestamp)) {
                    // Remove expired entry
                    delete cache[cacheKey];
                    this.saveCache(cache);
                    return null;
                }

                console.log(`Cache hit for: ${topic} (${difficulty})`);
                return entry.questions;
            }

            static set(topic, difficulty, questions) {
                if (!topic || !difficulty || !questions || !Array.isArray(questions)) return;

                const cacheKey = this.generateCacheKey(topic, difficulty);
                if (!cacheKey) return;

                let cache = this.loadCache();

                // Implement cache size limit
                const cacheKeys = Object.keys(cache);
                if (cacheKeys.length >= CONFIG.MAX_CACHE_SIZE) {
                    // Remove oldest entries
                    const sortedKeys = cacheKeys.sort((a, b) => cache[a].timestamp - cache[b].timestamp);
                    const keysToRemove = sortedKeys.slice(0, cacheKeys.length - CONFIG.MAX_CACHE_SIZE + 1);
                    
                    keysToRemove.forEach(key => delete cache[key]);
                }

                // Add new entry
                cache[cacheKey] = {
                    questions: questions,
                    timestamp: Date.now(),
                    metadata: {
                        topic: topic,
                        difficulty: difficulty,
                        questionsCount: questions.length
                    }
                };

                this.saveCache(cache);
                console.log(`Cached questions for: ${topic} (${difficulty})`);
            }

            static cleanup() {
                const cache = this.loadCache();
                const cleanedCache = {};
                let removedCount = 0;

                Object.keys(cache).forEach(key => {
                    if (!this.isExpired(cache[key].timestamp)) {
                        cleanedCache[key] = cache[key];
                    } else {
                        removedCount++;
                    }
                });

                if (removedCount > 0) {
                    this.saveCache(cleanedCache);
                    console.log(`Cleaned up ${removedCount} expired cache entries`);
                }

                return removedCount;
            }

            static getCacheStats() {
                const cache = this.loadCache();
                const entries = Object.values(cache);
                const totalQuestions = entries.reduce((sum, entry) => sum + entry.questions.length, 0);
                const expiredCount = entries.filter(entry => this.isExpired(entry.timestamp)).length;

                return {
                    totalEntries: entries.length,
                    totalQuestions: totalQuestions,
                    expiredEntries: expiredCount,
                    activeEntries: entries.length - expiredCount
                };
            }

            static clear() {
                try {
                    localStorage.removeItem(CONFIG.CACHE_KEY);
                    console.log('Question cache cleared');
                } catch (error) {
                    console.error('Error clearing question cache:', error);
                }
            }
        }

        // Phase 4: Data Export/Import Manager
        class DataExportManager {
            static getAllUserData() {
                const data = {
                    exportTimestamp: new Date().toISOString(),
                    exportVersion: '4.2',
                    data: {
                        preferences: DataManager.loadPreferences(),
                        history: DataManager.loadHistory(),
                        favorites: DataManager.loadFavorites(),
                        stats: DataManager.loadStats(),
                        streaks: DataManager.loadStreaksAndMilestones(),
                        theme: localStorage.getItem(CONFIG.THEME_KEY),
                        cache: QuestionCache.loadCache()
                    }
                };
                return data;
            }

            static exportData() {
                try {
                    const data = this.getAllUserData();
                    const jsonString = JSON.stringify(data, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `sage-data-export-${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showNetworkMessage('Data exported successfully!', 'success');
                    console.log('User data exported successfully');
                } catch (error) {
                    console.error('Error exporting data:', error);
                    showNetworkMessage('Error exporting data. Please try again.', 'error');
                }
            }

            static importData(file) {
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        this.validateAndImportData(importedData);
                    } catch (error) {
                        console.error('Error parsing import file:', error);
                        showNetworkMessage('Invalid file format. Please select a valid SAGE export file.', 'error');
                    }
                };
                reader.readAsText(file);
            }

            static validateAndImportData(importedData) {
                try {
                    // Basic validation
                    if (!importedData.data || typeof importedData.data !== 'object') {
                        throw new Error('Invalid data structure');
                    }

                    const confirmed = confirm(
                        'This will replace all your current data including preferences, history, favorites, and stats. ' +
                        'Are you sure you want to continue?\n\n' +
                        `Import file created: ${importedData.exportTimestamp || 'Unknown date'}`
                    );

                    if (!confirmed) return;

                    // Import each data type
                    const { data } = importedData;
                    
                    if (data.preferences) {
                        localStorage.setItem(CONFIG.PREFERENCES_KEY, JSON.stringify(data.preferences));
                    }
                    
                    if (data.history) {
                        localStorage.setItem(CONFIG.HISTORY_KEY, JSON.stringify(data.history));
                    }
                    
                    if (data.favorites) {
                        localStorage.setItem(CONFIG.FAVORITES_KEY, JSON.stringify(data.favorites));
                    }
                    
                    if (data.stats) {
                        localStorage.setItem(CONFIG.STATS_KEY, JSON.stringify(data.stats));
                    }
                    
                    if (data.streaks) {
                        localStorage.setItem(CONFIG.STREAKS_KEY, JSON.stringify(data.streaks));
                    }
                    
                    if (data.theme) {
                        localStorage.setItem(CONFIG.THEME_KEY, data.theme);
                    }
                    
                    if (data.cache) {
                        localStorage.setItem(CONFIG.CACHE_KEY, JSON.stringify(data.cache));
                    }

                    showNetworkMessage('Data imported successfully! Refreshing page...', 'success');
                    
                    // Refresh the page to reload all data
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                    
                } catch (error) {
                    console.error('Error importing data:', error);
                    showNetworkMessage('Error importing data. Please check the file format.', 'error');
                }
            }

            static clearAllData() {
                const confirmed = confirm(
                    'This will permanently delete ALL your data including:\n' +
                    '‚Ä¢ User preferences\n' +
                    '‚Ä¢ Question history\n' +
                    '‚Ä¢ Favorite questions\n' +
                    '‚Ä¢ Usage statistics\n' +
                    '‚Ä¢ Achievement streaks\n' +
                    '‚Ä¢ Cached questions\n\n' +
                    'This action cannot be undone. Are you absolutely sure?'
                );

                if (!confirmed) return;

                const doubleConfirm = confirm('Last chance! This will delete everything. Continue?');
                if (!doubleConfirm) return;

                try {
                    // Clear all localStorage data except API key
                    const apiKey = localStorage.getItem(CONFIG.STORAGE_KEY);
                    
                    localStorage.removeItem(CONFIG.PREFERENCES_KEY);
                    localStorage.removeItem(CONFIG.HISTORY_KEY);
                    localStorage.removeItem(CONFIG.FAVORITES_KEY);
                    localStorage.removeItem(CONFIG.STATS_KEY);
                    localStorage.removeItem(CONFIG.STREAKS_KEY);
                    localStorage.removeItem(CONFIG.THEME_KEY);
                    localStorage.removeItem(CONFIG.CACHE_KEY);
                    
                    showNetworkMessage('All data cleared successfully! Refreshing page...', 'success');
                    
                    // Refresh the page
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                    
                } catch (error) {
                    console.error('Error clearing data:', error);
                    showNetworkMessage('Error clearing data. Please try again.', 'error');
                }
            }

            static getDataSummary() {
                const data = this.getAllUserData().data;
                return {
                    preferences: Object.keys(data.preferences || {}).length,
                    history: (data.history || []).length,
                    favorites: (data.favorites || []).length,
                    stats: data.stats ? 1 : 0,
                    streaks: data.streaks ? 1 : 0,
                    cache: Object.keys(data.cache || {}).length
                };
            }
        }

        // Phase 4: Celebration Engine for Achievement Animations
        class CelebrationEngine {
            constructor() {
                this.confettiContainer = null;
                this.colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7', '#a29bfe'];
                this.isActive = false;
            }

            init() {
                this.createConfettiContainer();
            }

            createConfettiContainer() {
                this.confettiContainer = document.createElement('div');
                this.confettiContainer.className = 'confetti-container';
                document.body.appendChild(this.confettiContainer);
            }

            celebrate(achievementType = 'default', intensity = 'medium') {
                if (this.isActive) return;
                
                this.isActive = true;
                
                // Create celebration burst
                this.createCelebrationBurst();
                
                // Create confetti
                this.createConfetti(intensity);
                
                // Add sparkles
                this.createSparkles();
                
                // Reset active state after animation
                setTimeout(() => {
                    this.isActive = false;
                }, 3000);
            }

            createCelebrationBurst() {
                const burst = document.createElement('div');
                burst.className = 'celebration-burst';
                
                // Position at center of screen
                burst.style.left = '50%';
                burst.style.top = '50%';
                burst.style.marginLeft = '-100px';
                burst.style.marginTop = '-100px';
                
                document.body.appendChild(burst);
                
                // Remove after animation
                setTimeout(() => {
                    if (burst.parentNode) {
                        burst.remove();
                    }
                }, 600);
            }

            createConfetti(intensity = 'medium') {
                const counts = {
                    low: 30,
                    medium: 50,
                    high: 80
                };
                
                const confettiCount = counts[intensity] || counts.medium;
                
                for (let i = 0; i < confettiCount; i++) {
                    setTimeout(() => {
                        this.createConfettiPiece();
                    }, i * 50);
                }
            }

            createConfettiPiece() {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                
                // Random shape
                const shapes = ['circle', 'square', 'triangle'];
                const shape = shapes[Math.floor(Math.random() * shapes.length)];
                if (shape !== 'circle') {
                    confetti.classList.add(shape);
                }
                
                // Random color
                const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                if (shape === 'triangle') {
                    confetti.style.borderBottomColor = color;
                } else {
                    confetti.style.backgroundColor = color;
                }
                
                // Random starting position
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.top = '-10px';
                
                // Random animation duration and delay
                const duration = 2 + Math.random() * 2; // 2-4 seconds
                const delay = Math.random() * 0.5; // 0-0.5 second delay
                confetti.style.animationDuration = duration + 's';
                confetti.style.animationDelay = delay + 's';
                
                // Random horizontal drift
                const drift = (Math.random() - 0.5) * 200; // -100px to 100px
                confetti.style.setProperty('--drift', drift + 'px');
                
                this.confettiContainer.appendChild(confetti);
                
                // Remove after animation
                setTimeout(() => {
                    if (confetti.parentNode) {
                        confetti.remove();
                    }
                }, (duration + delay + 0.5) * 1000);
            }

            createSparkles() {
                const sparkleCount = 12;
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                for (let i = 0; i < sparkleCount; i++) {
                    setTimeout(() => {
                        this.createSparkle(centerX, centerY, i);
                    }, i * 100);
                }
            }

            createSparkle(centerX, centerY, index) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                
                // Position sparkles in a circle around the center
                const angle = (index / 12) * 2 * Math.PI;
                const radius = 80 + Math.random() * 40;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                sparkle.style.left = x + 'px';
                sparkle.style.top = y + 'px';
                sparkle.style.animationDelay = Math.random() * 0.5 + 's';
                
                document.body.appendChild(sparkle);
                
                // Remove after animation
                setTimeout(() => {
                    if (sparkle.parentNode) {
                        sparkle.remove();
                    }
                }, 2000);
            }

            enhanceAchievementNotification(notification) {
                notification.classList.add('achievement-celebration');
                
                // Add extra sparkles around the notification
                const rect = notification.getBoundingClientRect();
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const sparkle = document.createElement('div');
                        sparkle.className = 'sparkle';
                        sparkle.style.position = 'fixed';
                        sparkle.style.left = (rect.left + Math.random() * rect.width) + 'px';
                        sparkle.style.top = (rect.top + Math.random() * rect.height) + 'px';
                        sparkle.style.zIndex = '1002';
                        
                        document.body.appendChild(sparkle);
                        
                        setTimeout(() => {
                            if (sparkle.parentNode) {
                                sparkle.remove();
                            }
                        }, 1500);
                    }, i * 200);
                }
            }
        }

        // Phase 4: Swipe Gesture Handler for Mobile Question Navigation
        class SwipeHandler {
            constructor() {
                this.startX = 0;
                this.startY = 0;
                this.startTime = 0;
                this.isActive = false;
                this.minSwipeDistance = 50;
                this.maxSwipeTime = 300;
                this.maxVerticalDistance = 100;
            }

            init() {
                if (!this.isTouchDevice()) return;
                
                this.attachEventListeners();
                console.log('Swipe gesture handler initialized');
            }

            isTouchDevice() {
                return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            }

            attachEventListeners() {
                const questionsContainer = document.getElementById('mathQuestionsList');
                if (!questionsContainer) return;

                questionsContainer.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                questionsContainer.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                questionsContainer.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
            }

            handleTouchStart(e) {
                // Only handle if we have multiple questions
                if (totalQuestions <= 1) return;
                
                const touch = e.touches[0];
                this.startX = touch.clientX;
                this.startY = touch.clientY;
                this.startTime = Date.now();
                this.isActive = true;
            }

            handleTouchMove(e) {
                if (!this.isActive) return;
                
                // Prevent default scrolling if we're in a horizontal swipe
                const touch = e.touches[0];
                const deltaX = Math.abs(touch.clientX - this.startX);
                const deltaY = Math.abs(touch.clientY - this.startY);
                
                if (deltaX > deltaY && deltaX > 20) {
                    e.preventDefault();
                }
            }

            handleTouchEnd(e) {
                if (!this.isActive) return;
                
                this.isActive = false;
                
                // Only handle if we have multiple questions
                if (totalQuestions <= 1) return;
                
                const touch = e.changedTouches[0];
                const endX = touch.clientX;
                const endY = touch.clientY;
                const endTime = Date.now();
                
                const deltaX = endX - this.startX;
                const deltaY = Math.abs(endY - this.startY);
                const deltaTime = endTime - this.startTime;
                
                // Check if this is a valid swipe
                if (Math.abs(deltaX) < this.minSwipeDistance) return;
                if (deltaY > this.maxVerticalDistance) return;
                if (deltaTime > this.maxSwipeTime) return;
                
                // Determine swipe direction
                if (deltaX > 0) {
                    // Swipe right - go to previous question
                    this.handleSwipe('right');
                } else {
                    // Swipe left - go to next question
                    this.handleSwipe('left');
                }
            }

            handleSwipe(direction) {
                const canNavigate = this.checkNavigationBounds(direction);
                
                if (!canNavigate) {
                    this.showSwipeFeedback('blocked');
                    return;
                }
                
                this.showSwipeFeedback('success');
                
                // Navigate with a small delay for visual feedback
                setTimeout(() => {
                    if (direction === 'left') {
                        navigateQuestion(1); // Next question
                    } else {
                        navigateQuestion(-1); // Previous question
                    }
                }, 100);
                
                console.log(`Swipe ${direction} - navigating question`);
            }

            checkNavigationBounds(direction) {
                if (direction === 'left') {
                    return currentQuestionIndex < totalQuestions - 1;
                } else {
                    return currentQuestionIndex > 0;
                }
            }

            showSwipeFeedback(type) {
                const questionsContainer = document.getElementById('mathQuestionsList');
                if (!questionsContainer) return;
                
                questionsContainer.style.transition = 'transform 0.2s ease';
                
                if (type === 'success') {
                    questionsContainer.style.transform = 'scale(0.98)';
                    setTimeout(() => {
                        questionsContainer.style.transform = '';
                    }, 200);
                } else if (type === 'blocked') {
                    questionsContainer.style.transform = 'translateX(10px)';
                    setTimeout(() => {
                        questionsContainer.style.transform = 'translateX(-10px)';
                        setTimeout(() => {
                            questionsContainer.style.transform = '';
                        }, 100);
                    }, 100);
                }
            }
        }

        // Phase 4: Animated Background Mathematical Elements
        class MathBackground {
            constructor() {
                this.container = null;
                this.symbols = ['œÄ', '‚àë', '‚à´', '‚àû', 'Œ±', 'Œ≤', 'Œ≥', 'Œ¥', 'Œ∏', 'Œª', 'Œº', 'œÉ', 'œÜ', 'œà', 'œâ', '‚àö', '‚àÜ', '‚àÇ', '‚âà', '‚â†', '‚â§', '‚â•', '‚àà', '‚äÇ', '‚à™', '‚à©', '‚Üí', '‚Üî', '¬±', '√ó', '√∑'];
                this.isActive = false;
                this.animationIntervals = [];
            }

            init() {
                this.createContainer();
                this.start();
            }

            createContainer() {
                this.container = document.createElement('div');
                this.container.className = 'math-background';
                document.body.appendChild(this.container);
            }

            createFloatingSymbol() {
                const symbol = document.createElement('div');
                symbol.className = 'floating-symbol';
                
                // Random symbol
                const randomSymbol = this.symbols[Math.floor(Math.random() * this.symbols.length)];
                symbol.textContent = randomSymbol;
                
                // Random size
                const sizes = ['small', 'medium', 'large'];
                const randomSize = sizes[Math.floor(Math.random() * sizes.length)];
                symbol.classList.add(randomSize);
                
                // Random starting position and animation type
                const animationType = Math.random() > 0.7 ? 'horizontal' : 'vertical';
                
                if (animationType === 'horizontal') {
                    symbol.classList.add('horizontal');
                    symbol.style.top = Math.random() * 80 + 10 + '%';
                    symbol.style.left = '-5%';
                } else {
                    symbol.style.left = Math.random() * 90 + 5 + '%';
                    symbol.style.top = '105%';
                }
                
                // Random delay
                symbol.style.animationDelay = Math.random() * 5 + 's';
                
                // Random duration variation
                const baseDuration = animationType === 'horizontal' ? 20 : 15;
                const duration = baseDuration + (Math.random() * 10 - 5);
                symbol.style.animationDuration = duration + 's';
                
                this.container.appendChild(symbol);
                
                // Remove symbol after animation
                setTimeout(() => {
                    if (symbol.parentNode) {
                        symbol.remove();
                    }
                }, (duration + 2) * 1000);
            }

            start() {
                if (this.isActive) return;
                
                this.isActive = true;
                
                // Create initial symbols
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        if (this.isActive) this.createFloatingSymbol();
                    }, i * 1000);
                }
                
                // Continue creating symbols at intervals
                const verticalInterval = setInterval(() => {
                    if (this.isActive) {
                        this.createFloatingSymbol();
                    } else {
                        clearInterval(verticalInterval);
                    }
                }, 3000);
                
                const horizontalInterval = setInterval(() => {
                    if (this.isActive) {
                        this.createFloatingSymbol();
                    } else {
                        clearInterval(horizontalInterval);
                    }
                }, 5000);
                
                this.animationIntervals.push(verticalInterval, horizontalInterval);
            }

            stop() {
                this.isActive = false;
                this.animationIntervals.forEach(interval => clearInterval(interval));
                this.animationIntervals = [];
                
                if (this.container) {
                    this.container.innerHTML = '';
                }
            }

            toggle() {
                if (this.isActive) {
                    this.stop();
                } else {
                    this.start();
                }
            }
        }

        // Initialize the application
        function initializeApp() {
            console.log('Initializing app...');
            
            // Phase 4: Initialize responsive layout manager
            window.layoutManager = new ResponsiveLayoutManager();
            
            // Phase 4: Clean up expired cache entries on startup
            QuestionCache.cleanup();
            
            // Phase 4: Initialize animated background
            window.mathBackground = new MathBackground();
            window.mathBackground.init();
            
            // Phase 4: Initialize swipe gestures for mobile navigation
            window.swipeHandler = new SwipeHandler();
            window.swipeHandler.init();
            
            // Phase 4: Initialize celebration engine
            window.celebrationEngine = new CelebrationEngine();
            window.celebrationEngine.init();
            
            // Load saved API key first
            const apiKeyInput = document.getElementById('apiKeyInput');
            const apiKeyContainer = document.getElementById('apiKeyContainer');
            
            const savedApiKey = localStorage.getItem(CONFIG.STORAGE_KEY);
            if (savedApiKey && apiKeyInput && apiKeyContainer) {
                apiKeyInput.value = savedApiKey;
                apiKeyContainer.style.display = 'none';
                console.log('Loaded saved API key');
            }

            // Attach event listeners first
            attachEventListeners();
            
            // Initialize core features with delay to ensure DOM is ready
            setTimeout(() => {
                console.log('Initializing smart input features...');
                initializeSmartInput();
                
                // Check if KaTeX is loaded
                checkKaTeXLoaded();
                
                // Initialize mobile enhancements
                initializeMobileFeatures();
                
                // Initialize network monitoring
                initializeNetworkMonitoring();
                
                // Check for Google Drive availability (optional)
                checkGoogleDriveAvailability();

                // Phase 3: Load user preferences and apply them
                loadAndApplyUserPreferences();
                
                // Phase 3: Initialize personalization features AFTER core features
                setTimeout(() => {
                    console.log('Initializing personalization features...');
                    initializePersonalizationFeatures();
                }, 200);
                
                // Phase 4: Initialize theme system
                initializeThemeSystem();
            }, 150);
        }
        
        // Attach all event listeners with proper null checks
        function attachEventListeners() {
            console.log('Attaching event listeners...');
            
            const generateQuestionsBtn = document.getElementById('generateQuestionsBtn');
            const resetBtn = document.getElementById('resetBtn');
            const toggleMathViewBtn = document.getElementById('toggleMathViewBtn');
            const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
            const exportQuestionsBtn = document.getElementById('exportQuestionsBtn');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const prevQuestionBtn = document.getElementById('prevQuestionBtn');
            const nextQuestionBtn = document.getElementById('nextQuestionBtn');
            
            // Phase 4: Data management buttons
            const exportDataBtn = document.getElementById('exportDataBtn');
            const importDataBtn = document.getElementById('importDataBtn');
            const clearDataBtn = document.getElementById('clearDataBtn');
            const importFileInput = document.getElementById('importFileInput');
            
            if (generateQuestionsBtn) {
                generateQuestionsBtn.addEventListener('click', generateMathQuestions);
                console.log('Attached generateMathQuestions event');
            } else {
                console.error('generateQuestionsBtn not found');
            }
            
            if (resetBtn) {
                resetBtn.addEventListener('click', resetGenerator);
                console.log('Attached resetGenerator event');
            } else {
                console.error('resetBtn not found');
            }
            
            if (toggleMathViewBtn) {
                toggleMathViewBtn.addEventListener('click', toggleMathView);
                console.log('Attached toggleMathView event');
            } else {
                console.error('toggleMathViewBtn not found');
            }
            
            if (saveApiKeyBtn) {
                saveApiKeyBtn.addEventListener('click', saveApiKey);
                console.log('Attached saveApiKey event');
            } else {
                console.error('saveApiKeyBtn not found');
            }
            
            if (exportQuestionsBtn) {
                exportQuestionsBtn.addEventListener('click', exportQuestions);
                console.log('Attached exportQuestions event');
            } else {
                console.error('exportQuestionsBtn not found');
            }
            
            if (apiKeyInput) {
                apiKeyInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveApiKey();
                    }
                });
                console.log('Attached apiKeyInput Enter key event');
            } else {
                console.error('apiKeyInput not found');
            }
            
            if (prevQuestionBtn) {
                prevQuestionBtn.addEventListener('click', () => navigateQuestion(-1));
                console.log('Attached prevQuestion event');
            } else {
                console.error('prevQuestionBtn not found');
            }
            
            if (nextQuestionBtn) {
                nextQuestionBtn.addEventListener('click', () => navigateQuestion(1));
                console.log('Attached nextQuestion event');
            } else {
                console.error('nextQuestionBtn not found');
            }
            
            // Phase 4: Data management event handlers
            if (exportDataBtn) {
                exportDataBtn.addEventListener('click', () => {
                    DataExportManager.exportData();
                });
                console.log('Attached exportData event');
            }
            
            if (importDataBtn) {
                importDataBtn.addEventListener('click', () => {
                    importFileInput.click();
                });
                console.log('Attached importData event');
            }
            
            if (clearDataBtn) {
                clearDataBtn.addEventListener('click', () => {
                    DataExportManager.clearAllData();
                });
                console.log('Attached clearData event');
            }
            
            if (importFileInput) {
                importFileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        DataExportManager.importData(file);
                        // Reset file input
                        e.target.value = '';
                    }
                });
                console.log('Attached importFileInput event');
            }
            
            // Keyboard navigation support
            document.addEventListener('keydown', handleKeyboardNavigation);
            console.log('Attached keyboard navigation');
        }
        
        // Check if Google Drive APIs are available (non-blocking)
        function checkGoogleDriveAvailability() {
            const statusElement = document.getElementById('googleDriveStatus');
            if (statusElement) statusElement.textContent = 'Checking...';
            
            // Wait a moment for scripts to load
            setTimeout(() => {
                if (typeof window.gapi !== 'undefined' && typeof window.google !== 'undefined') {
                    googleDriveAvailable = true;
                    console.log('Google Drive APIs detected - multi-device sync available');
                    
                    if (statusElement) {
                        statusElement.textContent = 'Available (setup required)';
                        statusElement.className = 'text-blue-400';
                    }
                    
                    // Show setup button
                    const setupBtn = document.getElementById('googleDriveSetupBtn');
                    if (setupBtn) setupBtn.classList.remove('hidden');
                    
                    // Check if already configured
                    const savedClientId = localStorage.getItem('google_client_id');
                    if (savedClientId) {
                        if (statusElement) {
                            statusElement.textContent = 'Configured (ready to connect)';
                            statusElement.className = 'text-green-400';
                        }
                        
                        // Try to initialize Google Drive
                        initializeGoogleDrive(savedClientId);
                    }
                } else {
                    console.log('Google Drive APIs not available - using localStorage only');
                    
                    if (statusElement) {
                        statusElement.textContent = 'Not available';
                        statusElement.className = 'text-gray-500';
                    }
                }
            }, 3000);
        }
        
        function showGoogleDriveSetup() {
            const panel = document.getElementById('googleDriveSetupPanel');
            if (panel) {
                panel.classList.remove('hidden');
                
                // Load saved client ID if exists
                const savedClientId = localStorage.getItem('google_client_id');
                if (savedClientId) {
                    document.getElementById('googleClientId').value = savedClientId;
                }
                
                // Show current origin for easy copying
                const originDisplay = document.getElementById('currentOriginDisplay');
                if (originDisplay) {
                    originDisplay.textContent = window.location.origin;
                }
            }
        }
        
        function hideGoogleDriveSetup() {
            const panel = document.getElementById('googleDriveSetupPanel');
            if (panel) panel.classList.add('hidden');
        }
        
        function saveGoogleDriveConfig() {
            const clientId = document.getElementById('googleClientId').value.trim();
            
            if (!clientId) {
                displayMessage('Please enter the Google Client ID', 'text-red-500');
                return;
            }
            
            if (!clientId.includes('.googleusercontent.com')) {
                displayMessage('Please enter a valid Google Client ID', 'text-red-500');
                return;
            }
            
            // Save the client ID
            localStorage.setItem('google_client_id', clientId);
            
            // Update UI
            const statusElement = document.getElementById('googleDriveStatus');
            if (statusElement) {
                statusElement.textContent = 'Configured (ready to connect)';
                statusElement.className = 'text-green-400';
            }
            
            hideGoogleDriveSetup();
            displayMessage('Google Drive configured successfully!', 'text-green-400');
            
            // Try to initialize with the new client ID
            initializeGoogleDrive(clientId);
        }
        
        // Initialize Google Drive with client ID
        async function initializeGoogleDrive(clientId) {
            if (!googleDriveAvailable) return;
            
            try {
                console.log('Initializing Google Drive...');
                
                // Check if running from file:// protocol
                const isLocalFile = window.location.protocol === 'file:';
                if (isLocalFile) {
                    console.warn('Google Drive requires HTTPS or localhost. Try running: python -m http.server 8000');
                    
                    const statusElement = document.getElementById('googleDriveStatus');
                    if (statusElement) {
                        statusElement.textContent = 'Setup error';
                        statusElement.className = 'text-red-400';
                    }
                    
                    displayMessage('Google Drive requires HTTPS or localhost. Try running: python -m http.server 8000', 'text-yellow-400');
                    return;
                }
                
                // Initialize gapi client
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Timeout')), 10000);
                    
                    window.gapi.load('client:auth2', {
                        callback: () => {
                            clearTimeout(timeout);
                            resolve();
                        },
                        onerror: (error) => {
                            clearTimeout(timeout);
                            reject(error);
                        }
                    });
                });
                
                // Initialize client with cookiePolicy for local testing
                const initConfig = {
                    clientId: clientId,
                    discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
                    scope: 'https://www.googleapis.com/auth/drive.file'
                };
                
                if (isLocalFile) {
                    initConfig.cookiePolicy = 'single_host_origin';
                }
                
                await window.gapi.client.init(initConfig);
                
                console.log('Google Drive initialized successfully');
                
                // Update status and add connect button
                const statusElement = document.getElementById('googleDriveStatus');
                if (statusElement) {
                    statusElement.textContent = 'Ready to connect';
                    statusElement.className = 'text-green-400';
                }
                
                addGoogleDriveConnectButton();
                
            } catch (error) {
                console.error('Failed to initialize Google Drive:', error);
                console.error('Error details:', error.message || error.details);
                
                const statusElement = document.getElementById('googleDriveStatus');
                if (statusElement) {
                    statusElement.textContent = 'Setup error';
                    statusElement.className = 'text-red-400';
                }
                
                let errorMsg = 'Failed to initialize Google Drive. Please check your credentials.';
                
                // Handle different error types
                if (error.message && error.message.includes('Invalid cookiePolicy')) {
                    errorMsg = 'Google Drive requires HTTPS or localhost. Try running: python -m http.server 8000';
                } else if (error.error === 'idpiframe_initialization_failed' || 
                          (error.details && error.details.includes('Not a valid origin'))) {
                    const currentOrigin = window.location.origin;
                    errorMsg = `OAuth error: ${currentOrigin} is not authorized. Add this URL to your Google Cloud Console OAuth settings under "Authorized JavaScript origins".`;
                } else if (error.message) {
                    errorMsg = `Google Drive error: ${error.message}`;
                } else if (error.details) {
                    errorMsg = `Google Drive error: ${error.details}`;
                }
                
                displayMessage(errorMsg, 'text-red-500');
            }
        }
        
        function addGoogleDriveConnectButton() {
            const setupBtn = document.getElementById('googleDriveSetupBtn');
            if (setupBtn && !document.getElementById('googleDriveConnectBtn')) {
                const connectBtn = document.createElement('button');
                connectBtn.id = 'googleDriveConnectBtn';
                connectBtn.className = 'text-xs bg-green-600 hover:bg-green-700 text-white px-2 py-1 rounded transition-colors ml-2';
                connectBtn.textContent = 'Connect';
                connectBtn.onclick = connectToGoogleDrive;
                
                setupBtn.parentNode.appendChild(connectBtn);
            }
        }
        
        // Connect to Google Drive
        async function connectToGoogleDrive() {
            try {
                const authInstance = window.gapi.auth2.getAuthInstance();
                googleUser = await authInstance.signIn();
                isGoogleSignedIn = true;
                
                console.log('Signed in to Google Drive successfully');
                
                // Update UI
                const statusElement = document.getElementById('googleDriveStatus');
                if (statusElement) {
                    const profile = googleUser.getBasicProfile();
                    statusElement.textContent = `Connected as ${profile.getName()}`;
                    statusElement.className = 'text-green-400';
                }
                
                // Hide connect button, show disconnect
                const connectBtn = document.getElementById('googleDriveConnectBtn');
                if (connectBtn) {
                    connectBtn.textContent = 'Disconnect';
                    connectBtn.className = 'text-xs bg-red-600 hover:bg-red-700 text-white px-2 py-1 rounded transition-colors ml-2';
                    connectBtn.onclick = disconnectFromGoogleDrive;
                }
                
                displayMessage('Connected to Google Drive successfully!', 'text-green-400');
                
            } catch (error) {
                console.error('Failed to connect to Google Drive:', error);
                displayMessage('Failed to connect to Google Drive', 'text-red-500');
            }
        }
        
        async function disconnectFromGoogleDrive() {
            try {
                const authInstance = window.gapi.auth2.getAuthInstance();
                await authInstance.signOut();
                
                isGoogleSignedIn = false;
                googleUser = null;
                
                // Update UI
                const statusElement = document.getElementById('googleDriveStatus');
                if (statusElement) {
                    statusElement.textContent = 'Ready to connect';
                    statusElement.className = 'text-green-400';
                }
                
                // Restore connect button
                const connectBtn = document.getElementById('googleDriveConnectBtn');
                if (connectBtn) {
                    connectBtn.textContent = 'Connect';
                    connectBtn.className = 'text-xs bg-green-600 hover:bg-green-700 text-white px-2 py-1 rounded transition-colors ml-2';
                    connectBtn.onclick = connectToGoogleDrive;
                }
                
                displayMessage('Disconnected from Google Drive', 'text-gray-400');
                
            } catch (error) {
                console.error('Failed to disconnect from Google Drive:', error);
            }
        }

        // Phase 3: Load and apply user preferences
        function loadAndApplyUserPreferences() {
            const preferences = DataManager.loadPreferences();
            
            const difficultySelect = document.getElementById('difficulty');
            const mathTopicInput = document.getElementById('mathTopic');
            
            // Apply preferred difficulty
            if (difficultySelect && preferences.preferredDifficulty) {
                difficultySelect.value = preferences.preferredDifficulty;
            }
            
            // Set last used topic if available
            if (mathTopicInput && preferences.lastUsedTopic) {
                mathTopicInput.value = preferences.lastUsedTopic;
            }
        }

        // Phase 4: Theme System Functions
        function initializeThemeSystem() {
            console.log('Initializing theme system...');
            
            // Load saved theme preference or default to dark
            const savedTheme = localStorage.getItem('sage-theme') || 'dark';
            applyTheme(savedTheme);
            
            // Set up theme toggle button
            const themeToggleBtn = document.getElementById('themeToggle');
            if (themeToggleBtn) {
                themeToggleBtn.addEventListener('click', toggleTheme);
                console.log('Theme toggle button initialized');
            } else {
                console.error('Theme toggle button not found');
            }
        }
        
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
            
            // Save preference
            localStorage.setItem('sage-theme', newTheme);
            
            console.log(`Theme switched to: ${newTheme}`);
        }
        
        function applyTheme(theme) {
            // Apply theme to document root
            document.documentElement.setAttribute('data-theme', theme);
            
            // Update theme icon
            const themeIcon = document.querySelector('#themeToggle .theme-icon');
            if (themeIcon) {
                themeIcon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
            }
            
            console.log(`Applied ${theme} theme`);
        }

        // Phase 3: Initialize personalization features
        function initializePersonalizationFeatures() {
            try {
                console.log('Adding personalization features...');
                
                // Add recently used topics section
                addRecentTopicsSection();
                
                // Add topic recommendations
                addTopicRecommendationsSection();
                
                // Add stats dashboard
                addStatsDashboard();
                
                // Update stats display (with error handling)
                setTimeout(() => {
                    try {
                        updateStatsDisplay();
                        console.log('Stats display updated successfully');
                    } catch (statsError) {
                        console.error('Error updating stats display:', statsError);
                        // Don't let stats errors break the app
                    }
                }, 100);
                
                console.log('Personalization features initialized successfully');
            } catch (error) {
                console.error('Error initializing personalization features:', error);
                // Don't let personalization errors break core functionality
            }
        }

        // Phase 3: Add recently used topics section
        function addRecentTopicsSection() {
            const recentTopics = DataManager.getRecentTopics(6);
            
            if (recentTopics.length === 0) return;
            
            const container = document.querySelector('.main-container');
            const topicInputContainer = document.getElementById('mathTopic').parentElement;
            
            console.log('Adding recent topics section...');
            console.log('Container found:', !!container);
            console.log('Topic input container found:', !!topicInputContainer);
            
            const recentSection = document.createElement('div');
            recentSection.className = 'mb-6';
            recentSection.innerHTML = `
                <label class="recent-topics-label">
                    üìö Recently Used Topics
                </label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-bottom: 1rem;" id="recentTopicsGrid">
                    ${recentTopics.map((item, index) => `
                        <button type="button" 
                                class="recent-topic-btn"
                                onclick="selectRecentTopic('${item.topic.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${item.difficulty}')"
                                title="Last used: ${item.lastUsed}">
                            <div class="recent-topic-title">${item.topic}</div>
                            <div class="flex items-center gap-2 mt-1">
                                ${createCategoryTag(item.topic)}
                                <div class="recent-topic-meta flex-1">${item.difficulty} ‚Ä¢ ${item.lastUsed}</div>
                            </div>
                        </button>
                    `).join('')}
                </div>
            `;
            
            // Safer insertion: insert after the topic input container
            try {
                if (topicInputContainer && topicInputContainer.parentElement === container) {
                    // Insert after the topic input container
                    topicInputContainer.insertAdjacentElement('afterend', recentSection);
                    console.log('Recent topics section added successfully');
                } else {
                    // Fallback: insert before footer to maintain proper order
                    console.log('Using fallback insertion method');
                    const footer = container.querySelector('.footer') || container.querySelector('footer');
                    if (footer) {
                        container.insertBefore(recentSection, footer);
                    } else {
                        container.appendChild(recentSection);
                    }
                }
            } catch (error) {
                console.error('Error adding recent topics section:', error);
            }
        }

        // Phase 3: Select a recent topic
        function selectRecentTopic(topic, difficulty) {
            const mathTopicInput = document.getElementById('mathTopic');
            const difficultySelect = document.getElementById('difficulty');
            
            if (mathTopicInput) mathTopicInput.value = topic;
            if (difficultySelect) difficultySelect.value = difficulty;
            if (mathTopicInput) mathTopicInput.focus();
            
            // Provide feedback
            displayMessage(`Selected: ${topic} (${difficulty})`, 'text-green-400');
        }

        // Phase 3: Topic Recommendation Engine
        class TopicRecommendationEngine {
            static getTopicRecommendations(currentTopic = '', limit = 4) {
                const stats = DataManager.loadStats();
                const history = DataManager.loadHistory();
                const preferences = DataManager.loadPreferences();
                
                // Base topic suggestions organized by category
                const topicDatabase = {
                    algebra: [
                        "Linear equations for Grade 9",
                        "Quadratic equations for Form 4", 
                        "Systems of equations for Grade 10",
                        "Polynomial operations for Form 5",
                        "Factoring techniques for Grade 9",
                        "Inequalities for Grade 10"
                    ],
                    geometry: [
                        "Circle theorems for Form 3",
                        "Triangle properties for Grade 8",
                        "Area and perimeter for Grade 7",
                        "3D shapes and volumes for Form 4",
                        "Coordinate geometry for Grade 10",
                        "Trigonometry basics for Form 4"
                    ],
                    calculus: [
                        "Limits and continuity for Form 6",
                        "Derivatives for A-Level",
                        "Integration for Form 6",
                        "Applications of calculus for Grade 12",
                        "Differential equations for A-Level"
                    ],
                    statistics: [
                        "Data analysis for Grade 9",
                        "Probability for Form 5",
                        "Normal distribution for A-Level",
                        "Hypothesis testing for Grade 12",
                        "Regression analysis for Form 6"
                    ],
                    advanced: [
                        "Complex numbers for Form 6",
                        "Vectors for Grade 12",
                        "Matrices for A-Level",
                        "Sequences and series for Form 5",
                        "Logarithms for Grade 11"
                    ]
                };
                
                let recommendations = [];
                
                // 1. Analyze current topic to suggest related topics
                if (currentTopic) {
                    const category = this.categorizeTopic(currentTopic);
                    if (category && topicDatabase[category]) {
                        recommendations.push(...topicDatabase[category]
                            .filter(topic => !topic.toLowerCase().includes(currentTopic.toLowerCase().split(' ')[0]))
                            .slice(0, 2));
                    }
                }
                
                // 2. Suggest topics based on user's favorite subjects
                const favoriteTopics = Object.entries(stats.favoriteTopics || {})
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 3)
                    .map(([topic]) => topic);
                
                favoriteTopics.forEach(favTopic => {
                    const category = this.categorizeTopic(favTopic);
                    if (category && topicDatabase[category]) {
                        recommendations.push(...topicDatabase[category]
                            .filter(topic => !recommendations.includes(topic))
                            .slice(0, 1));
                    }
                });
                
                // 3. Progressive difficulty suggestions
                const userPreferredDifficulty = preferences.preferredDifficulty || 'Medium';
                const nextLevel = this.getNextDifficultyLevel(userPreferredDifficulty);
                
                // 4. Fill remaining slots with popular topics
                const popularTopics = [
                    "Linear equations for Grade 9",
                    "Quadratic functions for Form 4",
                    "Circle theorems for Form 3",
                    "Trigonometry basics for Grade 10",
                    "Probability for Form 5",
                    "Derivatives for Form 6"
                ].filter(topic => !recommendations.includes(topic));
                
                recommendations.push(...popularTopics);
                
                // Remove duplicates and limit results
                recommendations = [...new Set(recommendations)].slice(0, limit);
                
                return recommendations.map(topic => ({
                    topic,
                    difficulty: this.suggestDifficulty(topic, userPreferredDifficulty),
                    reason: this.getRecommendationReason(topic, currentTopic, favoriteTopics)
                }));
            }
            
            static categorizeTopic(topic) {
                const topicLower = topic.toLowerCase();
                if (topicLower.includes('algebra') || topicLower.includes('equation') || topicLower.includes('polynomial')) return 'algebra';
                if (topicLower.includes('geometry') || topicLower.includes('triangle') || topicLower.includes('circle') || topicLower.includes('area')) return 'geometry';
                if (topicLower.includes('calculus') || topicLower.includes('derivative') || topicLower.includes('integral') || topicLower.includes('limit')) return 'calculus';
                if (topicLower.includes('statistic') || topicLower.includes('probability') || topicLower.includes('data')) return 'statistics';
                if (topicLower.includes('complex') || topicLower.includes('vector') || topicLower.includes('matrix')) return 'advanced';
                return 'algebra'; // default category
            }
            
            static getNextDifficultyLevel(currentLevel) {
                const levels = ['Easy', 'Medium', 'Hard', 'Challenging'];
                const currentIndex = levels.indexOf(currentLevel);
                return currentIndex < levels.length - 1 ? levels[currentIndex + 1] : currentLevel;
            }
            
            static suggestDifficulty(topic, userPreferred) {
                // Suggest appropriate difficulty based on topic complexity
                if (topic.includes('Grade 7') || topic.includes('Grade 8')) return 'Easy';
                if (topic.includes('Form 6') || topic.includes('A-Level') || topic.includes('Grade 12')) return 'Hard';
                return userPreferred;
            }
            
            static getRecommendationReason(topic, currentTopic, favoriteTopics) {
                if (currentTopic && this.categorizeTopic(topic) === this.categorizeTopic(currentTopic)) {
                    return 'Related to current topic';
                }
                if (favoriteTopics.some(fav => this.categorizeTopic(topic) === this.categorizeTopic(fav))) {
                    return 'Based on your interests';
                }
                return 'Popular topic';
            }
        }

        // Phase 3: Add topic recommendations section
        function addTopicRecommendationsSection() {
            const currentTopic = document.getElementById('mathTopic')?.value.trim() || '';
            const recommendations = TopicRecommendationEngine.getTopicRecommendations(currentTopic, 4);
            
            if (recommendations.length === 0) return;
            
            const container = document.querySelector('.main-container');
            const recentSection = document.getElementById('recentTopicsSection') || document.getElementById('mathTopic')?.parentElement;
            
            if (!container || !recentSection) return;
            
            // Remove existing recommendations section
            const existingRecommendations = document.getElementById('recommendationsSection');
            if (existingRecommendations) {
                existingRecommendations.remove();
            }
            
            const recommendationsSection = document.createElement('div');
            recommendationsSection.id = 'recommendationsSection';
            recommendationsSection.className = 'mb-6';
            recommendationsSection.innerHTML = `
                <label class="recommendation-topics-label">
                    üí° Recommended Topics for You
                </label>
                <div style="display: grid; grid-template-columns: 1fr; gap: 1rem; margin-bottom: 1rem;">
                    ${recommendations.map((item, index) => `
                        <button type="button" 
                                class="recommendation-btn"
                                onclick="selectRecommendedTopic('${item.topic.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${item.difficulty}')"
                                title="${item.reason}">
                            <div class="flex items-center gap-2 mb-2">
                                <div class="recommendation-title flex-1">${item.topic}</div>
                                ${createCategoryTag(item.topic)}
                            </div>
                            <div class="recommendation-meta">
                                <span class="recommendation-difficulty">${item.difficulty}</span>
                                <span class="recommendation-reason">${item.reason}</span>
                            </div>
                        </button>
                    `).join('')}
                </div>
            `;
            
            // Safer insertion after recent topics section if it exists
            try {
                if (document.getElementById('recentTopicsSection')) {
                    const recentTopicsSection = document.getElementById('recentTopicsSection');
                    recentTopicsSection.insertAdjacentElement('afterend', recommendationsSection);
                    console.log('Topic recommendations added after recent topics');
                } else {
                    // Fallback: insert before footer to maintain proper order
                    console.log('Using fallback: inserting recommendations before footer');
                    const footer = container.querySelector('.footer') || container.querySelector('footer');
                    if (footer) {
                        container.insertBefore(recommendationsSection, footer);
                    } else {
                        container.appendChild(recommendationsSection);
                    }
                }
            } catch (error) {
                console.error('Error adding topic recommendations section:', error);
                // Final fallback - insert before footer
                const footer = container.querySelector('.footer') || container.querySelector('footer');
                if (footer) {
                    container.insertBefore(recommendationsSection, footer);
                } else {
                    container.appendChild(recommendationsSection);
                }
            }
            
            console.log('Topic recommendations section update completed');
        }

        // Phase 3: Select a recommended topic
        function selectRecommendedTopic(topic, difficulty) {
            const mathTopicInput = document.getElementById('mathTopic');
            const difficultySelect = document.getElementById('difficulty');
            
            if (mathTopicInput) mathTopicInput.value = topic;
            if (difficultySelect) difficultySelect.value = difficulty;
            if (mathTopicInput) mathTopicInput.focus();
            
            // Provide feedback
            displayMessage(`Selected recommendation: ${topic} (${difficulty})`, 'text-blue-400');
            
            // Update recommendations based on new topic
            setTimeout(() => {
                console.log('Updating recommendations section...');
                addTopicRecommendationsSection();
                
                // Wait for DOM to update, then reposition dashboard
                setTimeout(() => {
                    console.log('Repositioning dashboard after recommendations update...');
                    addStatsDashboard();
                }, 100);
            }, 500);
        }

        // Phase 3: Add stats dashboard
        function addStatsDashboard() {
            console.log('Adding stats dashboard...');
            
            const container = document.querySelector('.main-container');
            
            console.log('Container found:', !!container);
            
            if (!container) {
                console.error('Main container not found for stats dashboard');
                return;
            }
            
            const statsSection = document.createElement('div');
            statsSection.className = 'mt-8 p-4 bg-gray-800 rounded-lg border border-gray-700';
            statsSection.innerHTML = `
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold text-white flex items-center gap-2">
                        üìä Your Progress
                    </h3>
                    <button type="button" 
                            class="text-xs text-gray-400 hover:text-gray-200 transition-colors"
                            onclick="toggleStatsDetails()"
                            id="statsToggleBtn">
                        Show Details
                    </button>
                </div>
                <div id="statsOverview" class="grid grid-cols-2 sm:grid-cols-4 gap-4 text-center">
                    <div class="stats-item">
                        <div class="text-2xl font-bold text-red-400" id="totalQuestions">0</div>
                        <div class="text-xs text-gray-400">Questions Generated</div>
                    </div>
                    <div class="stats-item">
                        <div class="text-2xl font-bold text-red-400" id="totalSessions">0</div>
                        <div class="text-xs text-gray-400">Study Sessions</div>
                    </div>
                    <div class="stats-item">
                        <div class="text-2xl font-bold text-red-400" id="topicsExplored">0</div>
                        <div class="text-xs text-gray-400">Topics Explored</div>
                    </div>
                    <div class="stats-item">
                        <div class="text-2xl font-bold text-orange-400" id="currentStreak">0</div>
                        <div class="text-xs text-gray-400">Day Streak üî•</div>
                    </div>
                </div>
                <div id="statsDetails" class="mt-4 space-y-3 hidden">
                    <div id="favoriteTopicsSection"></div>
                    <div id="difficultyDistributionSection"></div>
                    <div id="streakDetailsSection"></div>
                </div>
                
                <!-- Google Drive Status (optional) -->
                <div class="mt-3 pt-3 border-t border-gray-700 text-xs text-gray-400">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-2">
                            <span>‚òÅÔ∏è Google Drive:</span>
                            <span id="googleDriveStatus">Checking...</span>
                        </div>
                        <button id="googleDriveSetupBtn" class="text-xs bg-blue-600 hover:bg-blue-700 text-white px-2 py-1 rounded transition-colors hidden" onclick="showGoogleDriveSetup()">
                            Setup
                        </button>
                    </div>
                </div>
            `;
            
            try {
                // Always ensure dashboard is positioned at the bottom of the container
                const existingDashboard = container.querySelector('#statsOverview')?.parentElement;
                if (existingDashboard) {
                    existingDashboard.remove();
                    console.log('Removed existing dashboard to reposition');
                }
                
                // Simply append to the end of the container
                container.appendChild(statsSection);
                console.log('Stats dashboard added successfully at bottom position');
                
                // Immediate verification
                const insertedDashboard = document.querySelector('#statsOverview');
                const insertedDetails = document.querySelector('#statsDetails');
                const insertedFavorites = document.querySelector('#favoriteTopicsSection');
                const insertedDifficulty = document.querySelector('#difficultyDistributionSection');
                
                console.log('Dashboard verification:');
                console.log('- statsOverview found:', !!insertedDashboard);
                console.log('- statsDetails found:', !!insertedDetails);
                console.log('- favoriteTopicsSection found:', !!insertedFavorites);
                console.log('- difficultyDistributionSection found:', !!insertedDifficulty);
                
                if (insertedDashboard) {
                    console.log('Dashboard HTML structure confirmed in DOM');
                
                // Check if dashboard is visible (not hidden by CSS)
                const computedStyle = window.getComputedStyle(insertedDashboard);
                console.log('Dashboard display style:', computedStyle.display);
                console.log('Dashboard visibility:', computedStyle.visibility);
                console.log('Dashboard opacity:', computedStyle.opacity);
                
                // Check dashboard position in DOM
                console.log('Dashboard parent:', insertedDashboard.parentElement);
                console.log('Dashboard next sibling:', insertedDashboard.nextElementSibling);
                console.log('Dashboard class list:', insertedDashboard.className);
                } else {
                    console.error('Dashboard was not inserted properly into DOM');
                }
            } catch (error) {
                console.error('Error inserting stats dashboard:', error);
            }
        }

        // Phase 3: Update stats display
        function updateStatsDisplay() {
            const stats = DataManager.loadStats();
            const streakData = DataManager.loadStreaksAndMilestones();
            
            // Update main dashboard stats
            const totalQuestionsEl = document.getElementById('totalQuestions');
            const totalSessionsEl = document.getElementById('totalSessions');
            const topicsExploredEl = document.getElementById('topicsExplored');
            const currentStreakEl = document.getElementById('currentStreak');
            
            if (totalQuestionsEl) {
                totalQuestionsEl.textContent = stats.totalQuestions;
            }
            if (totalSessionsEl) {
                totalSessionsEl.textContent = stats.totalSessions;
            }
            if (topicsExploredEl) {
                topicsExploredEl.textContent = Object.keys(stats.favoriteTopics).length;
            }
            if (currentStreakEl) {
                currentStreakEl.textContent = streakData.currentStreak;
            }
            
            // Update detailed stats if visible (with small delay to ensure DOM is ready)
            setTimeout(() => {
                updateDetailedStats(stats);
                updateStreakDetails(streakData);
            }, 100);
        }

        // Phase 3: Update detailed stats
        function updateDetailedStats(stats) {
            const favoriteTopicsSection = document.getElementById('favoriteTopicsSection');
            const difficultyDistributionSection = document.getElementById('difficultyDistributionSection');
            
            // Only update if both elements exist
            if (!favoriteTopicsSection || !difficultyDistributionSection) {
                console.log('Stats detail elements not found - stats dashboard may not be initialized yet');
                return;
            }
            
            // Favorite topics
            const topTopics = Object.entries(stats.favoriteTopics)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 3);
            
            favoriteTopicsSection.innerHTML = topTopics.length > 0 ? `
                <div class="text-sm font-medium text-gray-300 mb-2">Most Practiced Topics:</div>
                <div class="space-y-1">
                    ${topTopics.map(([topic, count]) => `
                        <div class="flex justify-between text-xs">
                            <span class="text-gray-400 truncate">${topic}</span>
                            <span class="text-red-400">${count} times</span>
                        </div>
                    `).join('')}
                </div>
            ` : '<div class="text-xs text-gray-500">No topics practiced yet</div>';
            
            // Difficulty distribution
            const difficultyEntries = Object.entries(stats.difficultyDistribution);
            difficultyDistributionSection.innerHTML = difficultyEntries.length > 0 ? `
                <div class="text-sm font-medium text-gray-300 mb-2">Difficulty Breakdown:</div>
                <div class="grid grid-cols-2 gap-2">
                    ${difficultyEntries.map(([difficulty, count]) => `
                        <div class="flex justify-between text-xs">
                            <span class="text-gray-400">${difficulty}:</span>
                            <span class="text-red-400">${count}</span>
                        </div>
                    `).join('')}
                </div>
            ` : '<div class="text-xs text-gray-500">No difficulty data yet</div>';
        }

        // Phase 4: Update streak details
        function updateStreakDetails(streakData) {
            const streakDetailsSection = document.getElementById('streakDetailsSection');
            
            if (!streakDetailsSection) {
                console.log('Streak details section not found - stats dashboard may not be initialized yet');
                return;
            }
            
            // Recent achievements
            const recentAchievements = Object.values(streakData.milestones)
                .sort((a, b) => new Date(b.achievedDate) - new Date(a.achievedDate))
                .slice(0, 3);
            
            streakDetailsSection.innerHTML = `
                <div class="text-sm font-medium text-gray-300 mb-2">Streak Stats:</div>
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <div class="flex justify-between text-xs">
                        <span class="text-gray-400">Longest Streak:</span>
                        <span class="text-orange-400">${streakData.longestStreak} days</span>
                    </div>
                    <div class="flex justify-between text-xs">
                        <span class="text-gray-400">Total Days:</span>
                        <span class="text-orange-400">${streakData.totalDaysUsed}</span>
                    </div>
                </div>
                ${recentAchievements.length > 0 ? `
                    <div class="text-sm font-medium text-gray-300 mb-2">Recent Achievements:</div>
                    <div class="space-y-1">
                        ${recentAchievements.map(achievement => `
                            <div class="flex items-center justify-between text-xs p-2 bg-yellow-900/20 border border-yellow-600/30 rounded">
                                <span class="text-yellow-200 font-medium">üèÜ ${achievement.name}</span>
                                <span class="text-gray-400">${achievement.description}</span>
                            </div>
                        `).join('')}
                    </div>
                ` : '<div class="text-xs text-gray-500">No achievements yet - keep using SAGE!</div>'}
            `;
        }

        // Phase 4: Show achievement notifications with celebratory animations
        function showAchievementNotifications(achievements) {
            if (achievements.length === 0) return;
            
            // Trigger celebration animation for first achievement
            if (window.celebrationEngine) {
                const intensity = achievements.length > 1 ? 'high' : 'medium';
                window.celebrationEngine.celebrate('achievement', intensity);
            }
            
            achievements.forEach((achievement, index) => {
                setTimeout(() => {
                    const notification = document.createElement('div');
                    notification.className = 'fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full';
                    notification.style.backgroundColor = 'var(--surface)';
                    notification.style.border = '2px solid var(--accent)';
                    notification.style.color = 'var(--text-primary)';
                    notification.style.marginTop = `${index * 80}px`;
                    
                    notification.innerHTML = `
                        <div class="flex items-center gap-3">
                            <div class="text-2xl">üèÜ</div>
                            <div>
                                <div class="font-bold text-lg" style="color: var(--accent);">${achievement.name}</div>
                                <div class="text-sm" style="color: var(--text-secondary);">${achievement.description}</div>
                            </div>
                            <button onclick="this.parentElement.parentElement.remove()" class="ml-2 text-lg hover:opacity-70">√ó</button>
                        </div>
                    `;
                    
                    document.body.appendChild(notification);
                    
                    // Enhance notification with celebration effects
                    if (window.celebrationEngine) {
                        window.celebrationEngine.enhanceAchievementNotification(notification);
                    }
                    
                    // Animate in
                    setTimeout(() => {
                        notification.style.transform = 'translateX(0)';
                    }, 100);
                    
                    // Auto-remove after 6 seconds (slightly longer for celebration)
                    setTimeout(() => {
                        notification.style.transform = 'translateX(100%)';
                        setTimeout(() => {
                            if (notification.parentNode) {
                                notification.remove();
                            }
                        }, 300);
                    }, 6000);
                }, index * 500); // Stagger notifications
            });
        }

        // Phase 4: Create category tag HTML
        function createCategoryTag(topic, size = 'small') {
            // Defensive coding: handle undefined/null topic
            if (!topic || typeof topic !== 'string') {
                // Fallback to getting current topic from input field
                const mathTopicInput = document.getElementById('mathTopic');
                topic = mathTopicInput && mathTopicInput.value ? mathTopicInput.value.trim() : 'General';
            }
            
            const category = DataManager.categorizeTopicByKeywords(topic);
            const color = DataManager.getCategoryColor(category);
            const icon = DataManager.getCategoryIcon(category);
            
            const isSmall = size === 'small';
            const sizeClasses = isSmall ? 'text-xs px-2 py-1' : 'text-sm px-3 py-1.5';
            
            return `<span class="${sizeClasses} rounded-full font-medium inline-flex items-center gap-1" 
                          style="background-color: ${color}20; border: 1px solid ${color}40; color: ${color};">
                        <span>${icon}</span>
                        <span>${category}</span>
                    </span>`;
        }

        // Phase 3: Toggle stats details
        function toggleStatsDetails() {
            const details = document.getElementById('statsDetails');
            const toggleBtn = document.getElementById('statsToggleBtn');
            
            if (details.classList.contains('hidden')) {
                details.classList.remove('hidden');
                toggleBtn.textContent = 'Hide Details';
                updateDetailedStats(DataManager.loadStats());
                updateStreakDetails(DataManager.loadStreaksAndMilestones());
            } else {
                details.classList.add('hidden');
                toggleBtn.textContent = 'Show Details';
            }
        }

        
        // Phase 3: Update recent topics display
        function updateRecentTopicsDisplay() {
            const recentTopicsGrid = document.getElementById('recentTopicsGrid');
            if (!recentTopicsGrid) return;
            
            const recentTopics = DataManager.getRecentTopics(6);
            
            if (recentTopics.length === 0) {
                recentTopicsGrid.parentElement.style.display = 'none';
                return;
            }
            
            recentTopicsGrid.innerHTML = recentTopics.map((item, index) => `
                <button type="button" 
                        class="recent-topic-btn p-3 text-left bg-gray-800 hover:bg-gray-700 border border-gray-600 hover:border-red-500 rounded-lg transition-all duration-200 group"
                        onclick="selectRecentTopic('${item.topic.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${item.difficulty}')"
                        title="Last used: ${item.lastUsed}">
                    <div class="text-sm font-medium text-gray-200 group-hover:text-white truncate">${item.topic}</div>
                    <div class="text-xs text-gray-400 mt-1">${item.difficulty} ‚Ä¢ ${item.lastUsed}</div>
                </button>
            `).join('');
            
            recentTopicsGrid.parentElement.style.display = 'block';
        }
        
        // Phase 3: Add question to favorites
        function addToFavorites(problem, questionIndex, favoriteBtn) {
            const topic = mathTopicInput.value.trim();
            const difficulty = difficultySelect.value;
            
            DataManager.addToFavorites(
                problem.question,
                problem.correctAnswer,
                problem.stepByStepSolution,
                topic,
                difficulty
            );
            
            // Update button state
            favoriteBtn.textContent = '‚úì Favorited';
            favoriteBtn.disabled = true;
            favoriteBtn.className = 'action-btn bg-green-600 hover:bg-green-700';
            
            // Show success message
            displayMessage(`Question ${questionIndex + 1} added to favorites!`, 'text-green-400');
        }

        // Phase 3: Show favorites panel
        function showFavoritesPanel() {
            const favorites = DataManager.loadFavorites();
            
            if (favorites.length === 0) {
                displayMessage('No favorite questions yet. Click the star button on any question to add it to favorites!', 'text-yellow-400');
                return;
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4';
            overlay.innerHTML = `
                <div class="bg-gray-800 rounded-lg p-6 max-w-4xl w-full max-h-[80vh] overflow-y-auto border border-red-500/30">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-white flex items-center gap-2">
                            ‚≠ê Your Favorite Questions (${favorites.length})
                        </h3>
                        <button class="action-btn bg-red-600 hover:bg-red-700" onclick="this.closest('.fixed').remove()">
                            Close
                        </button>
                    </div>
                    <div class="space-y-4">
                        ${favorites.map((fav, index) => `
                            <div class="p-4 bg-gray-700 rounded-lg border border-gray-600">
                                <div class="flex justify-between items-start mb-2">
                                    <div class="text-sm text-gray-400">${fav.topic} ‚Ä¢ ${fav.difficulty} ‚Ä¢ ${fav.date}</div>
                                    <button class="text-red-400 hover:text-red-300 text-sm" onclick="removeFavorite(${fav.id}, this)">
                                        Remove
                                    </button>
                                </div>
                                <div class="text-white mb-2">${fav.question}</div>
                                <div class="text-gray-300 text-sm">
                                    <strong>Answer:</strong> ${fav.answer}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Close on ESC or click outside
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            });
            
            const closeOnEsc = (e) => {
                if (e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', closeOnEsc);
                }
            };
            document.addEventListener('keydown', closeOnEsc);
        }
        
        // Phase 3: Remove favorite
        function removeFavorite(favoriteId, buttonElement) {
            DataManager.removeFromFavorites(favoriteId);
            buttonElement.closest('.p-4').remove();
            displayMessage('Favorite removed!', 'text-orange-400');
        }
        
        // Mobile-specific features
        function initializeMobileFeatures() {
            // Add touch feedback to all buttons
            document.addEventListener('touchstart', function(e) {
                if (e.target.classList.contains('action-btn')) {
                    e.target.style.transform = 'scale(0.98)';
                }
            });
            
            document.addEventListener('touchend', function(e) {
                if (e.target.classList.contains('action-btn')) {
                    setTimeout(() => {
                        e.target.style.transform = '';
                    }, 100);
                }
            });
            
            // Improve mobile keyboard experience
            const inputs = document.querySelectorAll('input, textarea');
            inputs.forEach(input => {
                input.addEventListener('focus', () => {
                    // Scroll into view on mobile to prevent keyboard overlap
                    setTimeout(() => {
                        input.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 300);
                });
            });
            
            // Add pull-to-refresh hint (visual only)
            if (isMobileDevice()) {
                addPullToRefreshHint();
            }
        }
        
        // Detect mobile device
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Add subtle pull-to-refresh visual hint
        function addPullToRefreshHint() {
            const hint = document.createElement('div');
            hint.className = 'text-center text-gray-500 text-xs py-2';
            hint.textContent = '‚Üì Pull down to refresh ‚Üì';
            hint.style.opacity = '0.5';
            
            const container = document.querySelector('.main-container');
            container.insertBefore(hint, container.firstChild);
            
            // Simple pull-to-refresh detection
            let startY = 0;
            let currentY = 0;
            let pullDistance = 0;
            
            container.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
            });
            
            container.addEventListener('touchmove', (e) => {
                currentY = e.touches[0].clientY;
                pullDistance = currentY - startY;
                
                if (pullDistance > 0 && window.scrollY === 0) {
                    hint.style.opacity = Math.min(1, pullDistance / 100);
                    hint.style.transform = `translateY(${Math.min(pullDistance / 3, 20)}px)`;
                }
            });
            
            container.addEventListener('touchend', () => {
                if (pullDistance > 80 && window.scrollY === 0 && mathTopicInput.value.trim()) {
                    // Trigger refresh
                    if (!generateQuestionsBtn.disabled) {
                        generateMathQuestions();
                    }
                }
                
                // Reset hint
                hint.style.opacity = '0.5';
                hint.style.transform = 'translateY(0)';
                pullDistance = 0;
            });
        }

        // Network monitoring and fallback content
        function initializeNetworkMonitoring() {
            // Create network status indicator
            createNetworkStatusIndicator();
            
            // Monitor network status
            window.addEventListener('online', () => {
                isOnline = true;
                updateNetworkStatus();
                showNetworkMessage('üü¢ Connection restored!', 'success');
            });
            
            window.addEventListener('offline', () => {
                isOnline = false;
                updateNetworkStatus();
                showNetworkMessage('üî¥ No internet connection. Some features may be limited.', 'warning');
            });
            
            // Initial status update
            updateNetworkStatus();
        }
        
        function createNetworkStatusIndicator() {
            networkStatusIndicator = document.createElement('div');
            networkStatusIndicator.id = 'networkStatus';
            networkStatusIndicator.className = 'fixed top-4 right-4 z-50 px-3 py-2 rounded-lg text-sm font-medium transition-all duration-300';
            networkStatusIndicator.style.display = 'none';
            document.body.appendChild(networkStatusIndicator);
        }
        
        function updateNetworkStatus() {
            if (!networkStatusIndicator) return;
            
            if (isOnline) {
                networkStatusIndicator.className = networkStatusIndicator.className.replace(/bg-\w+-\d+/, 'bg-green-600');
                networkStatusIndicator.textContent = 'üü¢ Online';
                networkStatusIndicator.style.display = 'none'; // Hide when online
            } else {
                networkStatusIndicator.className = networkStatusIndicator.className.replace(/bg-\w+-\d+/, 'bg-red-600');
                networkStatusIndicator.textContent = 'üî¥ Offline';
                networkStatusIndicator.style.display = 'block';
            }
        }
        
        function showNetworkMessage(message, type) {
            const notification = document.createElement('div');
            notification.className = `fixed top-4 left-1/2 transform -translate-x-1/2 z-50 px-4 py-3 rounded-lg text-white font-medium transition-all duration-300 ${
                type === 'success' ? 'bg-green-600' : 'bg-orange-600'
            }`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }
        
        // Add fallback content for offline scenarios
        function getFallbackQuestions(topic, difficulty) {
            const fallbackQuestions = {
                easy: [
                    {
                        question: "Solve for x: $2x + 5 = 11$",
                        correctAnswer: "$x = 3$",
                        stepByStepSolution: "1. Subtract 5 from both sides: $2x = 6$\\n2. Divide both sides by 2: $x = 3$"
                    },
                    {
                        question: "What is $3 \\times 7$?",
                        correctAnswer: "$21$",
                        stepByStepSolution: "Simple multiplication: $3 \\times 7 = 21$"
                    },
                    {
                        question: "Find the area of a rectangle with length 5 cm and width 3 cm.",
                        correctAnswer: "$15 \\text{ cm}^2$",
                        stepByStepSolution: "Area = length √ó width = $5 \\times 3 = 15 \\text{ cm}^2$"
                    }
                ],
                medium: [
                    {
                        question: "Solve the quadratic equation: $x^2 - 5x + 6 = 0$",
                        correctAnswer: "$x = 2$ or $x = 3$",
                        stepByStepSolution: "1. Factor: $(x-2)(x-3) = 0$\\n2. Set each factor to zero: $x-2=0$ or $x-3=0$\\n3. Solve: $x = 2$ or $x = 3$"
                    },
                    {
                        question: "Find the derivative of $f(x) = 3x^2 + 2x - 1$",
                        correctAnswer: "$f'(x) = 6x + 2$",
                        stepByStepSolution: "Using power rule: $\\frac{d}{dx}[3x^2] = 6x$, $\\frac{d}{dx}[2x] = 2$, $\\frac{d}{dx}[-1] = 0$\\nTherefore: $f'(x) = 6x + 2$"
                    },
                    {
                        question: "Simplify: $\\frac{x^2 - 4}{x + 2}$ for $x \\neq -2$",
                        correctAnswer: "$x - 2$",
                        stepByStepSolution: "1. Factor numerator: $x^2 - 4 = (x+2)(x-2)$\\n2. Cancel common factor: $\\frac{(x+2)(x-2)}{x+2} = x-2$"
                    }
                ],
                hard: [
                    {
                        question: "Evaluate: $\\int_0^\\pi \\sin(x) \\, dx$",
                        correctAnswer: "$2$",
                        stepByStepSolution: "1. Find antiderivative: $\\int \\sin(x) \\, dx = -\\cos(x) + C$\\n2. Apply limits: $[-\\cos(x)]_0^\\pi = -\\cos(\\pi) - (-\\cos(0)) = -(-1) - (-1) = 2$"
                    },
                    {
                        question: "Find the limit: $\\lim_{x \\to 0} \\frac{\\sin(x)}{x}$",
                        correctAnswer: "$1$",
                        stepByStepSolution: "This is a standard limit. Using L'H√¥pital's rule or the squeeze theorem:\\n$\\lim_{x \\to 0} \\frac{\\sin(x)}{x} = 1$"
                    },
                    {
                        question: "Solve the system: $\\begin{cases} 2x + 3y = 7 \\\\ 4x - y = 2 \\end{cases}$",
                        correctAnswer: "$x = 1, y = \\frac{5}{3}$",
                        stepByStepSolution: "1. From equation 2: $y = 4x - 2$\\n2. Substitute into equation 1: $2x + 3(4x - 2) = 7$\\n3. Simplify: $2x + 12x - 6 = 7$, so $14x = 13$, thus $x = \\frac{13}{14}$\\n4. Find y: $y = 4(\\frac{13}{14}) - 2 = \\frac{26}{14} - 2 = \\frac{26-28}{14} = -\\frac{1}{7}$"
                    }
                ]
            };
            
            const difficultyLevel = difficulty.toLowerCase();
            const questions = fallbackQuestions[difficultyLevel] || fallbackQuestions.medium;
            
            // Return a copy to avoid modifying the original
            return questions.map(q => ({ ...q }));
        }
        
        // Enhanced API call with offline fallback
        async function makeAPICallWithRetry(url, payload, retries = CONFIG.MAX_RETRIES) {
            // Check if offline first
            if (!isOnline) {
                throw new Error('No internet connection available');
            }
            
            let lastError;
            
            for (let i = 0; i < retries; i++) {
                try {
                    // Show retry attempt if not first try
                    if (i > 0) {
                        updateLoadingMessage(`Retrying... (Attempt ${i + 1}/${retries})`);
                    }
                    
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        const errorMessage = errorData.error?.message || response.statusText;
                        throw new Error(`HTTP ${response.status}: ${errorMessage}`);
                    }

                    return await response.json();
                } catch (error) {
                    lastError = error;
                    console.error(`API call attempt ${i + 1} failed:`, error);
                    
                    if (i === retries - 1) {
                        throw error; // Last attempt failed
                    }
                    
                    // Progressive backoff: wait longer for each retry
                    const delay = CONFIG.RETRY_DELAY * Math.pow(2, i);
                    updateLoadingMessage(`Network issue detected. Retrying in ${delay/1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // Smart input features: autocomplete
        function initializeSmartInput() {
            setupAutocomplete();
            setupDifficultyDescriptions();
        }
        
        // Example topics data
        const exampleTopics = [
            "Linear equations for Grade 9",
            "Quadratic functions for Form 4", 
            "Trigonometry basics for Grade 10",
            "Calculus derivatives for Form 6",
            "Geometry proofs for Grade 8",
            "Statistics and probability for Form 5",
            "Algebraic expressions for Grade 7",
            "Circle theorems for Form 3",
            "Logarithms for Grade 11",
            "Complex numbers for Form 6",
            "Vectors for Grade 12",
            "Integration for A-Level"
        ];
        
        // Math topic suggestions for autocomplete
        const mathTopicSuggestions = [
            "Linear equations",
            "Quadratic equations", 
            "Exponential functions",
            "Logarithmic functions",
            "Trigonometric functions",
            "Polynomial functions",
            "Rational functions",
            "Systems of equations",
            "Inequalities",
            "Sequences and series",
            "Matrices",
            "Vectors",
            "Complex numbers",
            "Limits",
            "Derivatives",
            "Integration",
            "Differential equations",
            "Statistics",
            "Probability",
            "Combinatorics",
            "Number theory",
            "Geometry",
            "Circle theorems",
            "Triangle properties",
            "Coordinate geometry",
            "Transformations",
            "Similarity and congruence",
            "Area and volume",
            "Pythagoras theorem"
        ];
        
        
        function setupAutocomplete() {
            const dropdown = document.getElementById('autocompleteDropdown');
            const mathTopicInput = document.getElementById('mathTopic');
            let selectedIndex = -1;
            
            if (!dropdown || !mathTopicInput) {
                console.error('Autocomplete elements not found');
                return;
            }
            
            mathTopicInput.addEventListener('input', (e) => {
                const value = e.target.value.toLowerCase();
                if (value.length < 2) {
                    hideAutocomplete();
                    return;
                }
                
                const matches = mathTopicSuggestions.filter(suggestion => 
                    suggestion.toLowerCase().includes(value)
                ).slice(0, 8); // Limit to 8 suggestions
                
                if (matches.length > 0) {
                    showAutocomplete(matches);
                } else {
                    hideAutocomplete();
                }
                selectedIndex = -1;
            });
            
            mathTopicInput.addEventListener('keydown', (e) => {
                const items = dropdown.querySelectorAll('.autocomplete-item');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection(items);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    selectSuggestion(items[selectedIndex].textContent);
                } else if (e.key === 'Escape') {
                    hideAutocomplete();
                }
            });
            
            // Hide autocomplete when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.autocomplete-container')) {
                    hideAutocomplete();
                }
            });
            
            function showAutocomplete(suggestions) {
                dropdown.innerHTML = '';
                suggestions.forEach((suggestion, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.textContent = suggestion;
                    item.addEventListener('click', () => selectSuggestion(suggestion));
                    dropdown.appendChild(item);
                });
                dropdown.style.display = 'block';
            }
            
            function hideAutocomplete() {
                dropdown.style.display = 'none';
                selectedIndex = -1;
            }
            
            function updateSelection(items) {
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === selectedIndex);
                });
            }
            
            function selectSuggestion(suggestion) {
                const mathTopicInput = document.getElementById('mathTopic');
                if (mathTopicInput) {
                    const currentValue = mathTopicInput.value;
                    const words = currentValue.split(' ');
                    words[words.length - 1] = suggestion;
                    mathTopicInput.value = words.join(' ') + ' ';
                    hideAutocomplete();
                    mathTopicInput.focus();
                }
            }
        }
        
        function setupDifficultyDescriptions() {
            const difficultyDescriptions = {
                'Easy': 'Simple problems with basic concepts and clear solutions',
                'Medium': 'Moderate complexity with step-by-step explanations',
                'Hard': 'Advanced problems requiring deeper mathematical understanding',
                'Challenging': 'Complex multi-step problems for advanced learners'
            };
            
            const descriptionElement = document.getElementById('difficultyDescription');
            
            difficultySelect.addEventListener('change', (e) => {
                const selectedDifficulty = e.target.value;
                descriptionElement.textContent = difficultyDescriptions[selectedDifficulty] || 
                    difficultyDescriptions['Medium'];
            });
        }

        // Check if KaTeX is properly loaded
        function checkKaTeXLoaded() {
            if (typeof renderMathInElement === 'function' && typeof katex !== 'undefined') {
                isKaTeXLoaded = true;
                console.log('KaTeX loaded successfully');
            } else {
                isKaTeXLoaded = false;
                displayMessage('Warning: Math rendering library failed to load. Math expressions may not display correctly.', 'text-amber-400');
                console.error('KaTeX failed to load');
            }
        }

        // Event listeners
        generateQuestionsBtn.addEventListener('click', generateMathQuestions);
        resetBtn.addEventListener('click', resetGenerator);
        toggleMathViewBtn.addEventListener('click', toggleMathView);
        saveApiKeyBtn.addEventListener('click', saveApiKey);
        exportQuestionsBtn.addEventListener('click', exportQuestions);
        
        // Question navigation event listeners (removed - handled in attachEventListeners function)

        // Keyboard navigation support
        document.addEventListener('keydown', handleKeyboardNavigation);
        
        // Enter key support for API key input
        apiKeyInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveApiKey();
            }
        });

        // Enter key support for topic input is handled in setupAutocomplete()

        function handleKeyboardNavigation(e) {
            // ESC key to close revealed answers and hide error dialogs
            if (e.key === 'Escape') {
                // Close revealed answers
                document.querySelectorAll('.answer-content').forEach(content => {
                    if (content.style.display === 'block') {
                        content.style.display = 'none';
                        const revealBtn = content.parentElement.querySelector('.action-btn:last-child');
                        if (revealBtn) {
                            revealBtn.textContent = 'Show Answer & Steps';
                            revealBtn.setAttribute('aria-expanded', 'false');
                        }
                    }
                });
                
                // Hide error messages
                if (messageContainer.innerHTML.includes('bg-red-900/20')) {
                    messageContainer.innerHTML = '';
                }
                
                // Close API key container if visible
                if (apiKeyContainer.style.display === 'block') {
                    apiKeyContainer.style.display = 'none';
                }
            }
            
            // F5 or Ctrl+R to generate new questions (if topic is filled)
            if ((e.key === 'F5' || (e.ctrlKey && e.key === 'r')) && mathTopicInput.value.trim()) {
                e.preventDefault();
                if (!generateQuestionsBtn.disabled) {
                    generateMathQuestions();
                }
            }
            
            // Ctrl+K to focus on topic input
            if (e.ctrlKey && e.key === 'k') {
                e.preventDefault();
                const mathTopicInput = document.getElementById('mathTopic');
                if (mathTopicInput) {
                    mathTopicInput.focus();
                    mathTopicInput.select();
                }
            }
            
            // Ctrl+E to export questions (if available)
            if (e.ctrlKey && e.key === 'e' && currentQuestions.length > 0) {
                e.preventDefault();
                exportQuestions();
            }
            
            // Arrow keys for question navigation (if multiple questions)
            if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && totalQuestions > 1 && !questionsContainer.classList.contains('hidden')) {
                e.preventDefault();
                const direction = e.key === 'ArrowLeft' ? -1 : 1;
                navigateQuestion(direction);
            }
            
            // Number keys 1-3 to reveal specific answers (if questions are visible)
            if (['1', '2', '3'].includes(e.key) && questionsContainer.classList.contains('hidden') === false) {
                const questionIndex = parseInt(e.key) - 1;
                const questions = document.querySelectorAll('.question-item');
                if (questions[questionIndex]) {
                    const revealBtn = questions[questionIndex].querySelector('.action-btn:last-child');
                    if (revealBtn) {
                        revealBtn.click();
                    }
                }
            }
            
            // ? key to show keyboard shortcuts help
            if (e.key === '?' && !e.ctrlKey && !e.altKey) {
                e.preventDefault();
                showKeyboardShortcuts();
            }
            
            // Ctrl+F to show favorites
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                showFavoritesPanel();
            }
        }
        
        // Show keyboard shortcuts overlay
        function showKeyboardShortcuts() {
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
            overlay.innerHTML = `
                <div class="bg-gray-800 rounded-lg p-6 max-w-md mx-4 border border-red-500/30">
                    <h3 class="text-xl font-bold text-white mb-4 flex items-center gap-2">
                        ‚å®Ô∏è Keyboard Shortcuts
                    </h3>
                    <div class="space-y-2 text-sm">
                        <div class="flex justify-between"><span class="text-gray-300">Generate Questions:</span><span class="text-red-400">Ctrl + Enter</span></div>
                        <div class="flex justify-between"><span class="text-gray-300">Focus Topic Input:</span><span class="text-red-400">Ctrl + K</span></div>
                        <div class="flex justify-between"><span class="text-gray-300">Export Questions:</span><span class="text-red-400">Ctrl + E</span></div>
                        <div class="flex justify-between"><span class="text-gray-300">Navigate Questions:</span><span class="text-red-400">‚Üê ‚Üí</span></div>
                        <div class="flex justify-between"><span class="text-gray-300">Refresh/Regenerate:</span><span class="text-red-400">F5</span></div>
                        <div class="flex justify-between"><span class="text-gray-300">Show Answer 1-3:</span><span class="text-red-400">1, 2, 3</span></div>
                        <div class="flex justify-between"><span class="text-gray-300">Show Favorites:</span><span class="text-red-400">Ctrl + F</span></div>
                        <div class="flex justify-between"><span class="text-gray-300">Close Dialogs:</span><span class="text-red-400">Escape</span></div>
                        <div class="flex justify-between"><span class="text-gray-300">Show This Help:</span><span class="text-red-400">?</span></div>
                    </div>
                    <button class="mt-4 w-full action-btn bg-red-600 hover:bg-red-700" onclick="this.parentElement.parentElement.remove()">
                        Close (ESC)
                    </button>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Close on ESC or click outside
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            });
            
            const closeOnEsc = (e) => {
                if (e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', closeOnEsc);
                }
            };
            document.addEventListener('keydown', closeOnEsc);
        }

        // Export questions to text file
        function exportQuestions() {
            if (currentQuestions.length === 0) {
                displayMessage('No questions to export. Generate some questions first.', 'text-orange-400');
                return;
            }

            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const topic = mathTopicInput.value.trim() || 'Math Questions';
            const difficulty = difficultySelect.value;
            
            let exportContent = `Math Questions Export\n`;
            exportContent += `Generated on: ${new Date().toLocaleString()}\n`;
            exportContent += `Topic: ${topic}\n`;
            exportContent += `Difficulty: ${difficulty}\n`;
            exportContent += `\n${'='.repeat(50)}\n\n`;

            currentQuestions.forEach((problem, index) => {
                exportContent += `Problem ${index + 1}:\n`;
                exportContent += `${problem.question}\n\n`;
                exportContent += `Answer:\n${problem.correctAnswer}\n\n`;
                exportContent += `Solution:\n${problem.stepByStepSolution.replace(/\\n/g, '\n')}\n\n`;
                exportContent += `${'-'.repeat(30)}\n\n`;
            });

            // Create and download file
            const blob = new Blob([exportContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `sage-questions-${timestamp}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            displayMessage('Questions exported successfully!', 'text-green-400');
        }

        // Performance optimization: Debounced input validation
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Enhanced input validation
        function validateInput(topic) {
            if (!topic || topic.trim().length < 3) {
                return 'Please enter a maths topic with at least 3 characters.';
            }
            if (topic.length > 500) {
                return 'Maths topic is too long. Please keep it under 500 characters.';
            }
            
            // Check for potentially harmful content
            const suspiciousPatterns = [
                /<script/i,
                /javascript:/i,
                /on\w+\s*=/i,
                /data:text\/html/i
            ];
            
            if (suspiciousPatterns.some(pattern => pattern.test(topic))) {
                return 'Invalid characters detected in input. Please use only text and mathematical expressions.';
            }
            
            return null;
        }

        // Validate API key format
        function validateApiKey(apiKey) {
            if (!apiKey || apiKey.trim().length < 10) {
                return 'API key appears to be too short. Please check your Gemini API key.';
            }
            if (!/^[A-Za-z0-9_-]+$/.test(apiKey)) {
                return 'API key contains invalid characters. Please check your Gemini API key.';
            }
            return null;
        }

        // Sanitize HTML content
        function sanitizeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Save API key with validation
        function saveApiKey() {
            const apiKey = apiKeyInput.value.trim();
            
            const validationError = validateApiKey(apiKey);
            if (validationError) {
                displayMessage(validationError, 'text-red-500');
                apiKeyInput.focus();
                return;
            }
            
            localStorage.setItem(CONFIG.STORAGE_KEY, apiKey);
            apiKeyContainer.style.display = 'none';
            displayMessage('API key saved successfully!', 'text-green-400');
        }

        // Smart math preprocessing - handles API responses with math delimiters
        function preprocessMathContent(content) {
            if (!content) return content;
            
            console.log('üîç MATH PREPROCESSING DEBUG:');
            console.log('Raw content:', content.substring(0, 150));
            console.log('Content type:', typeof content);
            console.log('Content length:', content.length);
            
            // SMART HANDLING: If content has math delimiters, validate and fix them
            if (content.includes('$') || content.includes('\\[') || content.includes('\\(')) {
                console.log('üìê Content has math delimiters - performing smart validation');
                
                // Fix common issues with $$ \text{ patterns
                if (content.includes('$$ \\text{') || content.includes('$$\\text{')) {
                    console.log('üîß Fixing $$ \\text{ pattern');
                    let processed = content;
                    
                    // Handle $$ \text{...} $$ patterns - extract text content
                    processed = processed.replace(/\$\$\s*\\text\{([^}]*)\}\s*\$\$/g, '$1');
                    console.log('‚úÖ Fixed $$ \\text{} pattern:', processed);
                    return processed;
                }
                
                // For other math patterns, return as-is
                console.log('‚úÖ Valid math delimiters found - returning unchanged');
                return content;
            }
            
            // ULTRA-CONSERVATIVE: Only process if content is CLEARLY mathematical
            // Must have explicit mathematical structures, not just backslashes
            const hasClearMathStructure = /\\frac\{.*\}.*\{.*\}|\\sqrt\{.*\}|\\int.*d[xyz]|\\sum.*=.*\^.*|\\lim.*\\to/.test(content);
            
            if (!hasClearMathStructure) {
                console.log('‚úÖ No clear math structure detected - returning as regular text');
                return content;
            }
            
            // Additional safety: ensure it's not just regular text with escaped characters
            const wordCount = content.split(/\s+/).length;
            const hasRegularWords = /\b(the|and|or|in|on|at|to|for|of|with|by|from|about|into|through|during|before|after|above|below|up|down|out|off|over|under|again|further|then|once)\b/i.test(content);
            
            if (wordCount > 10 && hasRegularWords) {
                console.log('‚úÖ Detected regular sentence structure - returning as text');
                return content;
            }
            
            // Only now do minimal cleanup
            let processed = content;
            
            // Clean up \text{} wrappers ONLY if they exist (but preserve context)
            if (processed.includes('\\text{')) {
                const beforeCleanup = processed;
                processed = processed.replace(/\\text\{([^}]*)\}/g, '$1');
                console.log('üßπ Cleaned \\text{} wrappers:', beforeCleanup, '->', processed);
            }
            
            // Convert \n to line breaks ONLY if they exist
            if (processed.includes('\\n')) {
                processed = processed.replace(/\\n/g, '\n');
                console.log('üßπ Converted \\n to line breaks');
            }
            
            // FINAL CHECK: Only add delimiters if we're absolutely sure it's math
            if (hasClearMathStructure && processed.length < 200) {
                console.log('üî¢ ADDING math delimiters to confirmed mathematical content');
                console.log('Final processed:', processed);
                return `$$${processed}$$`;
            }
            
            console.log('‚úÖ Final result: returning as regular text');
            return processed;
        }
        
        // Function to render math when content is added to the DOM
        function renderMathContent(element) {
            if (!isKaTeXLoaded) {
                console.warn('KaTeX not loaded, skipping math rendering');
                return;
            }

            const mathElements = element.querySelectorAll('.math-rendered');
            mathElements.forEach(mathEl => {
                const originalContent = mathEl.innerHTML;
                const cacheKey = originalContent;
                
                if (mathRenderCache.has(cacheKey)) {
                    mathEl.innerHTML = mathRenderCache.get(cacheKey);
                } else {
                    try {
                        // Only render if content has math delimiters or LaTeX commands
                        if (originalContent.includes('$') || originalContent.includes('\\frac') || originalContent.includes('\\int') || originalContent.includes('\\sum')) {
                            // Render with KaTeX - let it handle the content naturally
                            renderMathInElement(mathEl, {
                                delimiters: [
                                    {left: "$$", right: "$$", display: true},
                                    {left: "$", right: "$", display: false}
                                ],
                                throwOnError: false,
                                errorColor: '#ef4444',
                                strict: false,
                                trust: false
                            });
                            
                            mathRenderCache.set(cacheKey, mathEl.innerHTML);
                        }
                        // If no math indicators, leave content as-is (don't process regular text)
                    } catch (error) {
                        console.error('Error rendering math:', error);
                        // Keep original content on error
                        mathEl.innerHTML = originalContent;
                    }
                }
            });
        }

        // Retry math rendering with delay
        function retryMathRendering(element, maxRetries = 3, delay = 500) {
            let retries = 0;
            
            const attemptRender = () => {
                if (retries >= maxRetries) {
                    console.warn('Max retries reached for math rendering');
                    return;
                }
                
                retries++;
                
                if (isKaTeXLoaded) {
                    renderMathContent(element);
                } else {
                    console.log(`Math rendering retry ${retries}/${maxRetries} - KaTeX not ready`);
                    setTimeout(attemptRender, delay);
                }
            };
            
            attemptRender();
        }

        // Function to toggle between rendered math and raw LaTeX
        function toggleMathView() {
            isMathRendered = !isMathRendered;
            toggleMathViewBtn.textContent = isMathRendered ? 'Toggle Math View (Rendered)' : 'Toggle Math View (Raw LaTeX)';

            document.querySelectorAll('.math-rendered').forEach(renderedDiv => {
                renderedDiv.style.display = isMathRendered ? 'block' : 'none';
            });
            document.querySelectorAll('.latex-view').forEach(latexDiv => {
                latexDiv.style.display = isMathRendered ? 'none' : 'block';
            });
        }

        // Modern clipboard API with fallback
        async function copyToClipboard(text) {
            try {
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(text);
                    displayMessage("Copied to clipboard!", "text-green-400");
                } else {
                    // Fallback for older browsers or non-secure contexts
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    const successful = document.execCommand('copy');
                    document.body.removeChild(textarea);
                    
                    if (successful) {
                        displayMessage("Copied to clipboard!", "text-green-400");
                    } else {
                        throw new Error('Copy command failed');
                    }
                }
            } catch (err) {
                console.error('Failed to copy: ', err);
                displayMessage("Failed to copy text. Please copy manually.", "text-red-500");
            }
            
            // Hide message after timeout
            setTimeout(() => { 
                if (messageContainer.innerHTML.includes('Copied to clipboard') || messageContainer.innerHTML.includes('Failed to copy')) {
                    messageContainer.innerHTML = ''; 
                }
            }, CONFIG.MESSAGE_TIMEOUT);
        }

        // Enhanced retry mechanism for API calls with better error handling
        async function makeAPICallWithRetry(url, payload, retries = CONFIG.MAX_RETRIES) {
            let lastError;
            
            for (let i = 0; i < retries; i++) {
                try {
                    // Show retry attempt if not first try
                    if (i > 0) {
                        updateLoadingMessage(`Retrying... (Attempt ${i + 1}/${retries})`);
                    }
                    
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        const errorMessage = errorData.error?.message || response.statusText;
                        throw new Error(`HTTP ${response.status}: ${errorMessage}`);
                    }

                    return await response.json();
                } catch (error) {
                    lastError = error;
                    console.error(`API call attempt ${i + 1} failed:`, error);
                    
                    if (i === retries - 1) {
                        throw error; // Last attempt failed
                    }
                    
                    // Progressive backoff: wait longer for each retry
                    const delay = CONFIG.RETRY_DELAY * Math.pow(2, i);
                    updateLoadingMessage(`Network issue detected. Retrying in ${delay/1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // Enhanced loading management with progress tracking
        let loadingProgress = 0;
        let loadingInterval;
        const loadingMessages = [
            "Analyzing your math topic...",
            "Consulting mathematical knowledge base...",
            "Crafting problems for your level...",
            "Adding solution steps...",
            "Formatting mathematical expressions...",
            "Almost ready!"
        ];

        function updateLoadingMessage(message) {
            const loadingMessageEl = document.getElementById('loadingMessage');
            if (loadingMessageEl) {
                loadingMessageEl.textContent = message;
            }
        }

        function updateProgress(percent) {
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
            }
        }

        function startLoadingAnimation() {
            loadingProgress = 0;
            updateProgress(0);
            updateLoadingMessage(loadingMessages[0]);
            
            // Simulate realistic progress
            loadingInterval = setInterval(() => {
                loadingProgress += Math.random() * 15 + 5; // 5-20% increments
                
                if (loadingProgress >= 100) {
                    loadingProgress = 100;
                    updateProgress(100);
                    updateLoadingMessage("Finalizing your questions...");
                    clearInterval(loadingInterval);
                } else {
                    updateProgress(loadingProgress);
                    const messageIndex = Math.min(
                        Math.floor(loadingProgress / 20), 
                        loadingMessages.length - 1
                    );
                    updateLoadingMessage(loadingMessages[messageIndex]);
                }
            }, 800 + Math.random() * 400); // 800-1200ms intervals
        }

        function stopLoadingAnimation() {
            if (loadingInterval) {
                clearInterval(loadingInterval);
                loadingInterval = null;
            }
            loadingProgress = 0;
            updateProgress(0);
        }

        // Get user-friendly error message with actionable suggestions
        function getErrorMessage(error) {
            const errorStr = error.message.toLowerCase();
            
            if (errorStr.includes('401') || errorStr.includes('invalid api key')) {
                return {
                    message: "Your API key appears to be invalid or expired.",
                    suggestion: "Please check your Gemini API key and make sure it's correctly entered.",
                    action: "show_api_key"
                };
            } else if (errorStr.includes('403') || errorStr.includes('forbidden')) {
                return {
                    message: "Access denied. Your API key may not have the required permissions.",
                    suggestion: "Ensure your Gemini API key has access to the Generative Language API.",
                    action: "show_api_key"
                };
            } else if (errorStr.includes('429') || errorStr.includes('rate limit')) {
                return {
                    message: "Too many requests. You've hit the rate limit.",
                    suggestion: "Please wait a few minutes before trying again, or check your API quota.",
                    action: "retry_later"
                };
            } else if (errorStr.includes('quota') || errorStr.includes('billing')) {
                return {
                    message: "API quota exceeded or billing issue detected.",
                    suggestion: "Check your Google Cloud billing account and API quotas.",
                    action: "check_billing"
                };
            } else if (errorStr.includes('network') || errorStr.includes('fetch')) {
                return {
                    message: "Network connection issue detected.",
                    suggestion: "Check your internet connection and try again.",
                    action: "retry"
                };
            } else if (errorStr.includes('json') || errorStr.includes('parse')) {
                return {
                    message: "Received malformed response from the API.",
                    suggestion: "This might be a temporary issue. Try generating questions again.",
                    action: "retry"
                };
            } else {
                return {
                    message: "An unexpected error occurred while generating questions.",
                    suggestion: "Try again with a simpler topic or different difficulty level.",
                    action: "retry"
                };
            }
        }

        // Enhanced error display with retry button
        function displayEnhancedError(error) {
            const errorInfo = getErrorMessage(error);
            
            const errorContainer = document.createElement('div');
            errorContainer.className = 'bg-red-900/20 border border-red-500/30 rounded-lg p-4 mt-4';
            
            errorContainer.innerHTML = `
                <div class="flex items-start gap-3">
                    <div class="text-red-400 text-xl">‚ö†Ô∏è</div>
                    <div class="flex-1">
                        <h4 class="text-red-400 font-semibold mb-2">${errorInfo.message}</h4>
                        <p class="text-gray-300 text-sm mb-3">${errorInfo.suggestion}</p>
                        <div class="flex gap-2 flex-wrap">
                            ${errorInfo.action === 'retry' ? '<button id="retryBtn" class="action-btn bg-red-600 hover:bg-red-700 text-sm">Try Again</button>' : ''}
                            ${errorInfo.action === 'show_api_key' ? '<button id="showApiKeyBtn" class="action-btn bg-blue-600 hover:bg-blue-700 text-sm">Update API Key</button>' : ''}
                            ${errorInfo.action === 'retry_later' ? '<button id="retryLaterBtn" class="action-btn bg-yellow-600 hover:bg-yellow-700 text-sm">Retry in 1 minute</button>' : ''}
                        </div>
                    </div>
                </div>
            `;
            
            messageContainer.innerHTML = '';
            messageContainer.appendChild(errorContainer);
            
            // Add event listeners for action buttons
            const retryBtn = errorContainer.querySelector('#retryBtn');
            const showApiKeyBtn = errorContainer.querySelector('#showApiKeyBtn');
            const retryLaterBtn = errorContainer.querySelector('#retryLaterBtn');
            
            if (retryBtn) {
                retryBtn.addEventListener('click', () => {
                    messageContainer.innerHTML = '';
                    generateMathQuestions();
                });
            }
            
            if (showApiKeyBtn) {
                showApiKeyBtn.addEventListener('click', () => {
                    apiKeyContainer.style.display = 'block';
                    apiKeyInput.focus();
                });
            }
            
            if (retryLaterBtn) {
                retryLaterBtn.addEventListener('click', () => {
                    retryLaterBtn.disabled = true;
                    retryLaterBtn.textContent = 'Waiting...';
                    setTimeout(() => {
                        messageContainer.innerHTML = '';
                        generateMathQuestions();
                    }, 60000); // 1 minute delay
                });
            }
        }

        async function generateMathQuestions() {
            const mathTopicInput = document.getElementById('mathTopic');
            const difficultySelect = document.getElementById('difficulty');
            
            if (!mathTopicInput || !difficultySelect) {
                console.error('Required input elements not found');
                displayMessage("Error: Required form elements not found.", "text-red-500");
                return;
            }
            
            const mathTopic = mathTopicInput.value.trim();
            const difficulty = difficultySelect.value;
            const apiKey = localStorage.getItem(CONFIG.STORAGE_KEY);

            // Validation
            if (!apiKey) {
                const apiKeyContainer = document.getElementById('apiKeyContainer');
                if (apiKeyContainer) {
                    apiKeyContainer.style.display = 'block';
                }
                displayMessage("Please enter your Gemini API key first.", "text-red-500");
                return;
            }

            const validationError = validateInput(mathTopic);
            if (validationError) {
                displayMessage(validationError, "text-red-500");
                return;
            }

            // Phase 4: Update usage streak and check for achievements
            const streakData = DataManager.updateUsageStreak();
            const newAchievements = DataManager.getNewAchievements();
            
            // Show achievement notifications if any
            if (newAchievements.length > 0) {
                showAchievementNotifications(newAchievements);
            }

            // Hide previous messages/questions, show loading
            const initialMessage = document.getElementById('initialMessage');
            const questionsContainer = document.getElementById('questionsContainer');
            const resetBtn = document.getElementById('resetBtn');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const generateQuestionsBtn = document.getElementById('generateQuestionsBtn');
            const mathQuestionsList = document.getElementById('mathQuestionsList');
            const messageContainer = document.getElementById('messageContainer');
            
            if (initialMessage) initialMessage.classList.add('hidden');
            if (questionsContainer) questionsContainer.classList.add('hidden');
            if (resetBtn) resetBtn.classList.add('hidden');
            if (loadingIndicator) loadingIndicator.classList.remove('hidden');
            if (generateQuestionsBtn) generateQuestionsBtn.disabled = true;
            if (mathQuestionsList) mathQuestionsList.innerHTML = '';
            if (messageContainer) messageContainer.innerHTML = '';
            
            // Start enhanced loading animation
            startLoadingAnimation();

            // Construct the prompt for the Gemini API
            const prompt = `
                Generate 3 math problems for the following topic and grade level, with a difficulty level of "${difficulty}".
                For each problem, provide:
                - A "question" in LaTeX format (use $$ for display math, $ for inline math).
                - A "correctAnswer" in LaTeX format.
                - A "stepByStepSolution" in LaTeX format, explaining how to solve the problem.

                Math Topic & Grade Level: ${sanitizeHTML(mathTopic)}
                Difficulty: ${difficulty}

                Provide the output as a JSON array of objects. Each object in the array represents one problem.
                Example JSON structure:
                [
                  {
                    "question": "$$2x + 5 = 11$$ Solve for x.",
                    "correctAnswer": "$$x = 3$$",
                    "stepByStepSolution": "To solve $2x + 5 = 11$: \\n 1. Subtract 5 from both sides: $2x = 11 - 5 \\implies 2x = 6$. \\n 2. Divide by 2: $x = 6 / 2 \\implies x = 3$."
                  },
                  {
                    "question": "What is the area of a rectangle with length $l = 5$ cm and width $w = 3$ cm?",
                    "correctAnswer": "$$15 \\text{ cm}^2$$",
                    "stepByStepSolution": "The area of a rectangle is given by the formula $A = l \\times w$. \\n Given $l=5$ cm and $w=3$ cm, \\n $A = 5 \\times 3 = 15 \\text{ cm}^2$."
                  }
                ]
                Ensure the LaTeX is correctly escaped for JSON strings.
            `;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    "question": { "type": "STRING" },
                                    "correctAnswer": { "type": "STRING" },
                                    "stepByStepSolution": { "type": "STRING" }
                                },
                                "propertyOrdering": ["question", "correctAnswer", "stepByStepSolution"]
                            }
                        }
                    }
                };

                // Phase 4: Check cache before making API call
                const cachedQuestions = QuestionCache.get(mathTopic, difficulty);
                if (cachedQuestions) {
                    console.log('Using cached questions');
                    displayMathQuestions(cachedQuestions);
                    return;
                }

                const apiUrl = `${CONFIG.API_BASE_URL}?key=${apiKey}`;
                const result = await makeAPICallWithRetry(apiUrl, payload);

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonText = result.candidates[0].content.parts[0].text;
                    try {
                        console.log("Raw API response text:", jsonText);
                        const mathProblems = JSON.parse(jsonText);
                        console.log("Parsed math problems:", mathProblems);
                        
                        if (Array.isArray(mathProblems) && mathProblems.length > 0) {
                            // Phase 4: Cache the questions before displaying
                            QuestionCache.set(mathTopic, difficulty, mathProblems);
                            displayMathQuestions(mathProblems);
                        } else {
                            console.error("Response is not a valid array:", mathProblems);
                            throw new Error('Invalid response format - not an array or empty');
                        }
                    } catch (parseError) {
                        console.error("Error parsing JSON response:", parseError);
                        console.error("Raw response that failed to parse:", jsonText);
                        displayMessage("Sorry, I received an invalid response format. Please try again.", "text-red-500");
                    }
                } else {
                    displayMessage("Sorry, I couldn't generate math problems. Please check your API key and try again.", "text-red-500");
                    console.error("Gemini API response structure unexpected:", result);
                }

            } catch (error) {
                console.error("Error generating math questions:", error);
                
                // Try fallback content if offline or network error
                if (!isOnline || error.message.includes('No internet connection') || error.message.includes('network') || error.message.includes('fetch')) {
                    updateLoadingMessage("Using offline fallback questions...");
                    setTimeout(() => {
                        const fallbackQuestions = getFallbackQuestions(mathTopic, difficulty);
                        displayMathQuestions(fallbackQuestions);
                        showNetworkMessage('üìö Showing sample questions (offline mode)', 'warning');
                    }, 1000);
                } else {
                    displayEnhancedError(error);
                    
                    // Show API key container for auth errors
                    if (error.message.includes('401') || error.message.includes('403')) {
                        apiKeyContainer.style.display = 'block';
                    }
                }
            } finally {
                stopLoadingAnimation();
                const loadingIndicator = document.getElementById('loadingIndicator');
                const generateQuestionsBtn = document.getElementById('generateQuestionsBtn');
                
                if (loadingIndicator) loadingIndicator.classList.add('hidden');
                if (generateQuestionsBtn) generateQuestionsBtn.disabled = false;
            }
        }

        function displayMathQuestions(problems) {
            const mathQuestionsList = document.getElementById('mathQuestionsList');
            if (mathQuestionsList) {
                mathQuestionsList.innerHTML = ''; // Clear previous questions
            }
            currentQuestions = problems; // Store for export functionality
            totalQuestions = problems.length;
            currentQuestionIndex = 0; // Reset to first question
            
            if (!Array.isArray(problems) || problems.length === 0) {
                displayMessage("No math problems were generated. Please try with a different topic.", "text-orange-400");
                return;
            }

            problems.forEach((problem, index) => {
                const problemDiv = document.createElement('div');
                problemDiv.className = 'question-item';
                problemDiv.style.animationDelay = `${index * 0.1}s`; // Staggered animation
                problemDiv.setAttribute('role', 'listitem');

                const questionHeader = document.createElement('div');
                questionHeader.className = 'flex items-center justify-between mb-4';
                
                const questionTitle = document.createElement('h3');
                questionTitle.className = 'text-xl font-semibold';
                questionTitle.style.color = 'var(--text-primary)';
                questionTitle.textContent = `Problem ${index + 1}:`;
                
                const categoryTagDiv = document.createElement('div');
                categoryTagDiv.innerHTML = createCategoryTag(mathTopic, 'medium');
                
                questionHeader.appendChild(questionTitle);
                questionHeader.appendChild(categoryTagDiv);
                problemDiv.appendChild(questionHeader);

                // Container for rendered math
                const questionRenderedDiv = document.createElement('div');
                questionRenderedDiv.className = 'text-lg mb-4 math-rendered';
                questionRenderedDiv.style.color = 'var(--text-primary)';
                
                // Always preprocess the content to ensure proper math handling
                try {
                    console.log(`Question ${index + 1} raw content:`, problem.question.substring(0, 150) + '...');
                    const processedQuestion = preprocessMathContent(problem.question);
                    questionRenderedDiv.innerHTML = sanitizeHTML(processedQuestion);
                    console.log(`Question ${index + 1} after processing:`, processedQuestion.substring(0, 150) + '...');
                    console.log(`Question ${index + 1} has dollar signs:`, processedQuestion.includes('$'));
                } catch (error) {
                    console.error(`Error processing question ${index + 1}:`, error);
                    questionRenderedDiv.innerHTML = sanitizeHTML(problem.question);
                }
                problemDiv.appendChild(questionRenderedDiv);

                // Container for raw LaTeX
                const questionLatexDiv = document.createElement('div');
                questionLatexDiv.className = 'latex-view'; // Hidden by default initially
                questionLatexDiv.textContent = problem.question;
                problemDiv.appendChild(questionLatexDiv);

                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex flex-wrap gap-2 mt-4';

                const copyBtn = document.createElement('button');
                copyBtn.className = 'action-btn bg-gray-600 hover:bg-gray-700';
                copyBtn.textContent = 'Copy Question';
                copyBtn.setAttribute('aria-label', `Copy question ${index + 1}`);
                copyBtn.addEventListener('click', () => copyToClipboard(problem.question));
                buttonContainer.appendChild(copyBtn);

                const revealBtn = document.createElement('button');
                revealBtn.className = 'action-btn bg-red-600 hover:bg-red-700';
                revealBtn.textContent = 'Show Answer & Steps';
                revealBtn.setAttribute('aria-label', `Show answer and steps for question ${index + 1}`);
                buttonContainer.appendChild(revealBtn);

                const similarBtn = document.createElement('button');
                similarBtn.className = 'action-btn bg-blue-600 hover:bg-blue-700';
                similarBtn.textContent = 'Generate Similar';
                similarBtn.setAttribute('aria-label', `Generate similar question to ${index + 1}`);
                similarBtn.addEventListener('click', () => generateSimilarQuestion(problem, index));
                buttonContainer.appendChild(similarBtn);
                
                // Phase 3: Add favorite button
                const favoriteBtn = document.createElement('button');
                favoriteBtn.className = 'action-btn bg-yellow-600 hover:bg-yellow-700';
                favoriteBtn.textContent = '‚≠ê Favorite';
                favoriteBtn.setAttribute('aria-label', `Add question ${index + 1} to favorites`);
                favoriteBtn.addEventListener('click', () => addToFavorites(problem, index, favoriteBtn));
                buttonContainer.appendChild(favoriteBtn);

                problemDiv.appendChild(buttonContainer);

                const answerContentDiv = document.createElement('div');
                answerContentDiv.className = 'answer-content text-gray-300';
                
                // Minimal processing - preserve content as much as possible
                let processedAnswer = problem.correctAnswer;
                let processedSolution = problem.stepByStepSolution;
                
                // Only preprocess if there's LaTeX without delimiters
                if (problem.correctAnswer.includes('\\') && !problem.correctAnswer.includes('$')) {
                    processedAnswer = preprocessMathContent(problem.correctAnswer);
                }
                
                if (problem.stepByStepSolution.includes('\\') && !problem.stepByStepSolution.includes('$')) {
                    processedSolution = preprocessMathContent(problem.stepByStepSolution);
                }
                
                // Convert \n to line breaks but preserve other formatting
                processedSolution = processedSolution.replace(/\\n/g, '<br>');
                
                answerContentDiv.innerHTML = `<div class="mb-3 p-2 rounded text-xs" style="background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary);">
                                                 <span class="font-semibold">‚ö†Ô∏è AI Generated Content:</span> Please verify answers independently. AI responses may contain errors.
                                             </div>` +
                                             `<p class="font-bold mb-2" style="color: var(--accent);">Correct Answer:</p><div class="mb-4 math-rendered" style="color: var(--text-primary);">${sanitizeHTML(processedAnswer)}</div>` +
                                             `<div class="latex-view">${sanitizeHTML(problem.correctAnswer)}</div>` + // Raw LaTeX for answer
                                             `<p class="font-bold mb-2" style="color: var(--accent);">Step-by-Step Solution:</p><div class="math-rendered" style="color: var(--text-primary);">${sanitizeHTML(processedSolution)}</div>` +
                                             `<div class="latex-view">${sanitizeHTML(problem.stepByStepSolution.replace(/\\n/g, '<br>'))}</div>`; // Raw LaTeX for solution
                problemDiv.appendChild(answerContentDiv);

                revealBtn.addEventListener('click', () => {
                    const isVisible = answerContentDiv.style.display === 'block';
                    answerContentDiv.style.display = isVisible ? 'none' : 'block';
                    revealBtn.textContent = isVisible ? 'Show Answer & Steps' : 'Hide Answer & Steps';
                    revealBtn.setAttribute('aria-expanded', !isVisible);
                    
                    // Re-render math in the revealed section if it's currently rendered view
                    if (!isVisible && isMathRendered) {
                         retryMathRendering(answerContentDiv);
                    }
                });

                mathQuestionsList.appendChild(problemDiv);
            });

            questionsContainer.classList.remove('hidden');
            resetBtn.classList.remove('hidden');
            
            // Phase 4: Move questions to canvas on desktop
            if (window.layoutManager) {
                window.layoutManager.moveQuestionsToCanvas();
            }
            
            // Initialize question navigation
            if (totalQuestions > 1) {
                document.getElementById('questionNavigator').classList.remove('hidden');
                showQuestion(currentQuestionIndex);
                updateNavigationState();
            } else {
                // Show single question
                const questions = document.querySelectorAll('.question-item');
                if (questions.length > 0) {
                    questions[0].classList.add('active');
                }
            }
            
            // Phase 3: Save to history and update preferences
            const topic = mathTopicInput.value.trim();
            const difficulty = difficultySelect.value;
            
            // Update history and stats
            DataManager.addToHistory(topic, difficulty, problems.length);
            
            // Update user preferences
            const preferences = DataManager.loadPreferences();
            preferences.lastUsedTopic = topic;
            preferences.preferredDifficulty = difficulty;
            
            // Add to preferred topics if not already there
            const topicLower = topic.toLowerCase();
            if (!preferences.preferredTopics.some(t => t.toLowerCase() === topicLower)) {
                preferences.preferredTopics.unshift(topic);
                preferences.preferredTopics = preferences.preferredTopics.slice(0, 10); // Keep only top 10
            }
            
            DataManager.savePreferences(preferences);
            
            // Update UI components
            updateStatsDisplay();
            updateRecentTopicsDisplay();
            
            // Initial rendering of math after questions are added to DOM
            // Use retry mechanism to ensure KaTeX has time to initialize
            retryMathRendering(mathQuestionsList);
            
            // Ensure initial view state is applied based on isMathRendered
            document.querySelectorAll('.math-rendered').forEach(renderedDiv => {
                renderedDiv.style.display = isMathRendered ? 'block' : 'none';
            });
            document.querySelectorAll('.latex-view').forEach(latexDiv => {
                latexDiv.style.display = isMathRendered ? 'none' : 'block';
            });
        }

        // Question navigation functions
        function navigateQuestion(direction) {
            console.log(`Navigating from question ${currentQuestionIndex + 1} with direction ${direction}`);
            const newIndex = currentQuestionIndex + direction;
            console.log(`New index: ${newIndex + 1}, total questions: ${totalQuestions}`);
            
            if (newIndex >= 0 && newIndex < totalQuestions) {
                currentQuestionIndex = newIndex;
                console.log(`Current question index updated to: ${currentQuestionIndex + 1}`);
                showQuestion(currentQuestionIndex);
                updateNavigationState();
            } else {
                console.log('Navigation blocked - index out of bounds');
            }
        }
        
        function showQuestion(index) {
            const questions = document.querySelectorAll('.question-item');
            console.log(`Showing question ${index + 1}, total questions found: ${questions.length}`);
            
            questions.forEach((question, i) => {
                const isActive = i === index;
                question.classList.toggle('active', isActive);
                console.log(`Question ${i + 1}: ${isActive ? 'ACTIVE' : 'hidden'}`);
            });
            
            // Update counter
            const counter = document.getElementById('questionCounter');
            if (counter) {
                counter.textContent = `Question ${index + 1} of ${totalQuestions}`;
            }
        }
        
        function updateNavigationState() {
            const prevBtn = document.getElementById('prevQuestionBtn');
            const nextBtn = document.getElementById('nextQuestionBtn');
            
            prevBtn.disabled = currentQuestionIndex === 0;
            nextBtn.disabled = currentQuestionIndex === totalQuestions - 1;
        }

        // Generate similar question functionality
        async function generateSimilarQuestion(originalProblem, questionIndex) {
            const apiKey = localStorage.getItem(CONFIG.STORAGE_KEY);
            
            if (!apiKey) {
                showNetworkMessage('API key required for generating similar questions', 'warning');
                return;
            }
            
            if (!isOnline) {
                showNetworkMessage('Internet connection required for generating similar questions', 'warning');
                return;
            }
            
            // Show loading state for this specific question
            const similarBtn = document.querySelector(`[aria-label="Generate similar question to ${questionIndex + 1}"]`);
            const originalText = similarBtn.textContent;
            similarBtn.disabled = true;
            similarBtn.textContent = 'Generating...';
            
            try {
                const prompt = `
                    Generate 1 similar math problem to the following, keeping the same topic and difficulty level but with different numbers/context:
                    
                    Original Question: ${originalProblem.question}
                    
                    Generate a new problem that:
                    - Uses the same mathematical concepts
                    - Has similar difficulty level
                    - Uses different numbers or context
                    - Follows the same format with question, correctAnswer, and stepByStepSolution in LaTeX
                    
                    Provide the output as a JSON object:
                    {
                        "question": "...",
                        "correctAnswer": "...",
                        "stepByStepSolution": "..."
                    }
                `;
                
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "question": { "type": "STRING" },
                                "correctAnswer": { "type": "STRING" },
                                "stepByStepSolution": { "type": "STRING" }
                            }
                        }
                    }
                };
                
                // Phase 4: Check cache for similar question
                const similarCacheKey = `similar_${btoa(originalProblem.question).substring(0, 20)}`;
                const cachedSimilar = QuestionCache.get(similarCacheKey, 'similar');
                if (cachedSimilar && cachedSimilar.length > 0) {
                    console.log('Using cached similar question');
                    replaceProblemInList(questionIndex, cachedSimilar[0]);
                    showNetworkMessage('Similar question generated from cache!', 'success');
                    return;
                }

                const apiUrl = `${CONFIG.API_BASE_URL}?key=${apiKey}`;
                const result = await makeAPICallWithRetry(apiUrl, payload, 2); // Fewer retries for similar questions
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const newProblem = JSON.parse(jsonText);
                    
                    // Phase 4: Cache the similar question
                    QuestionCache.set(similarCacheKey, 'similar', [newProblem]);
                    
                    // Replace the current question with the similar one
                    replaceProblemInList(questionIndex, newProblem);
                    showNetworkMessage('Similar question generated!', 'success');
                } else {
                    throw new Error('Invalid response format');
                }
                
            } catch (error) {
                console.error('Error generating similar question:', error);
                showNetworkMessage('Failed to generate similar question. Please try again.', 'warning');
            } finally {
                similarBtn.disabled = false;
                similarBtn.textContent = originalText;
            }
        }
        
        // Replace a specific problem in the displayed list
        function replaceProblemInList(index, newProblem) {
            // Update the stored questions array
            currentQuestions[index] = newProblem;
            
            // Find the question element
            const questions = document.querySelectorAll('.question-item');
            const questionElement = questions[index];
            
            if (questionElement) {
                // Update the question content
                const questionRendered = questionElement.querySelector('.math-rendered');
                const questionLatex = questionElement.querySelector('.latex-view');
                
                if (questionRendered) {
                    if (newProblem.question.includes('\\') && !newProblem.question.includes('$')) {
                        const processedQuestion = preprocessMathContent(newProblem.question);
                        questionRendered.innerHTML = sanitizeHTML(processedQuestion);
                    } else {
                        questionRendered.innerHTML = sanitizeHTML(newProblem.question);
                    }
                }
                if (questionLatex) questionLatex.textContent = newProblem.question;
                
                // Update answer content
                const answerContentDiv = questionElement.querySelector('.answer-content');
                if (answerContentDiv) {
                    let processedAnswer = newProblem.correctAnswer;
                    let processedSolution = newProblem.stepByStepSolution;
                    
                    // Only preprocess if there's LaTeX without delimiters
                    if (newProblem.correctAnswer.includes('\\') && !newProblem.correctAnswer.includes('$')) {
                        processedAnswer = preprocessMathContent(newProblem.correctAnswer);
                    }
                    
                    if (newProblem.stepByStepSolution.includes('\\') && !newProblem.stepByStepSolution.includes('$')) {
                        processedSolution = preprocessMathContent(newProblem.stepByStepSolution);
                    }
                    
                    // Convert \n to line breaks
                    processedSolution = processedSolution.replace(/\\n/g, '<br>');
                    
                    answerContentDiv.innerHTML = `<div class="mb-3 p-2 rounded text-xs" style="background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary);">
                                                     <span class="font-semibold">‚ö†Ô∏è AI Generated Content:</span> Please verify answers independently. AI responses may contain errors.
                                                 </div>` +
                                                 `<p class="font-bold mb-2" style="color: var(--accent);">Correct Answer:</p><div class="mb-4 math-rendered" style="color: var(--text-primary);">${sanitizeHTML(processedAnswer)}</div>` +
                                                 `<div class="latex-view">${sanitizeHTML(newProblem.correctAnswer)}</div>` +
                                                 `<p class="font-bold mb-2" style="color: var(--accent);">Step-by-Step Solution:</p><div class="math-rendered" style="color: var(--text-primary);">${sanitizeHTML(processedSolution)}</div>` +
                                                 `<div class="latex-view">${sanitizeHTML(newProblem.stepByStepSolution.replace(/\\n/g, '<br>'))}</div>`;
                    
                    // Hide the answer initially
                    answerContentDiv.style.display = 'none';
                    const revealBtn = questionElement.querySelector('.action-btn:nth-child(2)'); // Second button (reveal)
                    if (revealBtn) {
                        revealBtn.textContent = 'Show Answer & Steps';
                        revealBtn.setAttribute('aria-expanded', 'false');
                    }
                }
                
                // Re-render math content
                retryMathRendering(questionElement);
                
                // Apply current view state
                const mathRenderedElements = questionElement.querySelectorAll('.math-rendered');
                const latexElements = questionElement.querySelectorAll('.latex-view');
                
                mathRenderedElements.forEach(el => {
                    el.style.display = isMathRendered ? 'block' : 'none';
                });
                latexElements.forEach(el => {
                    el.style.display = isMathRendered ? 'none' : 'block';
                });
            }
        }

        function resetGenerator() {
            const mathTopicInput = document.getElementById('mathTopic');
            const difficultySelect = document.getElementById('difficulty');
            const mathQuestionsList = document.getElementById('mathQuestionsList');
            const questionsContainer = document.getElementById('questionsContainer');
            const resetBtn = document.getElementById('resetBtn');
            const initialMessage = document.getElementById('initialMessage');
            const messageContainer = document.getElementById('messageContainer');
            
            if (mathTopicInput) mathTopicInput.value = ''; // Clear input
            if (difficultySelect) difficultySelect.value = 'Medium'; // Reset difficulty
            if (mathQuestionsList) mathQuestionsList.innerHTML = ''; // Clear questions
            currentQuestions = []; // Clear stored questions
            currentQuestionIndex = 0;
            totalQuestions = 0;
            
            const questionNavigator = document.getElementById('questionNavigator');
            if (questionNavigator) questionNavigator.classList.add('hidden'); // Hide navigator
            if (questionsContainer) questionsContainer.classList.add('hidden');
            if (resetBtn) resetBtn.classList.add('hidden');
            if (initialMessage) initialMessage.classList.remove('hidden'); // Show initial message again
            if (messageContainer) messageContainer.innerHTML = ''; // Clear any messages
        }

        function displayMessage(message, colorClass) {
            const messageElement = document.createElement('p');
            messageElement.className = `text-center ${colorClass} font-medium py-4`;
            messageElement.textContent = message;
            messageContainer.innerHTML = '';
            messageContainer.appendChild(messageElement);
            
            initialMessage.classList.add('hidden');
            loadingIndicator.classList.add('hidden');
            
            if (colorClass.includes('red') || colorClass.includes('amber')) {
                questionsContainer.classList.add('hidden'); // Hide questions if error
                resetBtn.classList.add('hidden');
            }
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', initializeApp);

        // Check KaTeX loading after a delay
        setTimeout(checkKaTeXLoaded, 1000);
    </script>
</body>
</html>
